<!DOCTYPE html>

<html lang="da">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>BBR PDF Data Ekstraktor</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .column-selection {
            margin-bottom: 30px;
        }

        .column-selection > label {
            display: block;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            font-size: 1.1rem;
        }

        .columns-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .column-checkbox {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .column-checkbox:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .column-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .column-checkbox label {
            cursor: pointer;
            font-size: 1rem;
            color: #333;
            user-select: none;
            flex: 1;
        }

        .column-checkbox.checked {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .quick-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quick-btn {
            padding: 8px 16px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s;
        }

        .quick-btn:hover {
            background: #667eea;
            color: white;
        }

        .upload-area {
            border: 3px dashed #d0d0d0;
            border-radius: 12px;
            padding: 50px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2rem;
            color: #555;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #888;
            font-size: 0.95rem;
        }

        #fileInput {
            display: none;
        }

        .file-list {
            margin-top: 25px;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .file-name {
            font-weight: 500;
            color: #333;
        }

        .file-remove {
            color: #ff4444;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px;
        }

        .file-remove:hover {
            color: #cc0000;
        }

        .process-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .process-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            display: block;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
            display: block;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            display: block;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 0.95rem;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.8rem;
            }

            .card {
                padding: 25px;
            }

            .insurance-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* Preview Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow: auto;
        }

        .modal.show {
            display: block;
        }

        .modal-content {
            background-color: white;
            margin: 20px auto;
            padding: 0;
            width: 95%;
            max-width: 1200px;
            border-radius: 12px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .modal-close {
            font-size: 2rem;
            cursor: pointer;
            color: white;
            line-height: 1;
            padding: 0 10px;
        }

        .modal-close:hover {
            opacity: 0.7;
        }

        .modal-body {
            padding: 20px 30px;
            overflow-y: auto;
            flex: 1;
        }

        .sheet-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .sheet-tab {
            padding: 10px 20px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .sheet-tab:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .sheet-tab.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .sheet-content {
            display: none;
        }

        .sheet-content.active {
            display: block;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.95rem;
        }

        .preview-table th {
            background: #f5f5f5;
            padding: 12px 10px;
            text-align: left;
            border: 1px solid #ddd;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .preview-table td {
            padding: 10px;
            border: 1px solid #ddd;
        }

        .preview-table tr:nth-child(even) {
            background: #fafafa;
        }

        .preview-table tr:hover {
            background: #f0f4ff;
        }

        .preview-table .total-row {
            background: #e3f2fd !important;
            font-weight: 600;
        }

        .modal-footer {
            padding: 20px 30px;
            border-top: 2px solid #e0e0e0;
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-btn-cancel {
            background: #e0e0e0;
            color: #333;
        }

        .modal-btn-cancel:hover {
            background: #d0d0d0;
        }

        .modal-btn-download {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modal-btn-download:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
    

.section-title{font-size:18px;font-weight:700;color:#2d3748;}
.section-desc{margin:6px 0 10px;color:#4a5568;font-size:13px;}
</style>
</head>
<body>
<div class="container">
<div class="header">
<h1>üìÑ BBR PDF Data Ekstraktor</h1>
<p>Upload BBR PDFer og f√• data i Excel format</p>
</div>
<div class="card">
<div class="column-selection">
<label>V√¶lg hvilke kolonner du vil have i Excel:</label>
<div class="quick-select">
<button class="quick-btn" onclick="selectAll()">V√¶lg alle</button>
<button class="quick-btn" onclick="deselectAll()">Frav√¶lg alle</button>
</div>
<div class="columns-grid" id="columnsGrid">
<div class="column-checkbox" onclick="toggleCheckbox('col1')">
<input checked="" id="col1" type="checkbox" value="Samlet bygningsareal"/>
<label for="col1">Samlet bygningsareal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col2')">
<input checked="" id="col2" type="checkbox" value="Samlet k√¶lderareal"/>
<label for="col2">Samlet k√¶lderareal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col3')">
<input checked="" id="col3" type="checkbox" value="Samlet tagetageareal"/>
<label for="col3">Samlet tagetageareal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col4')">
<input id="col4" type="checkbox" value="Heraf udnyttet tagetage"/>
<label for="col4">Heraf udnyttet tagetage</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col5')">
<input checked="" id="col5" type="checkbox" value="Samlet andet areal"/>
<label for="col5">Samlet andet areal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col6')">
<input checked="" id="col6" type="checkbox" value="Bebygget areal"/>
<label for="col6">Bebygget areal (bruges kun hvis andre ikke er udfyldt)</label>
</div>
</div>
<h3 class="section-title" style="margin-top:16px;">Anden data</h3>
<p class="section-desc">Valgfrit: Ekstra oplysninger pr. bygning. Disse bliver ikke summeret.</p>
<div class="columns-grid" id="otherColumnsGrid">
<div class="column-checkbox" onclick="toggleCheckbox('col7')">
<input id="col7" type="checkbox" value="Opf√∏relses√•r"/>
<label for="col7">Opf√∏relses√•r</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col8')">
<input id="col8" type="checkbox" value="Antal etager u. k√¶lder &amp; tagetage"/>
<label for="col8">Antal etager u. k√¶lder &amp; tagetage</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col9')">
<input id="col9" type="checkbox" value="Yderv√¶ggens materiale"/>
<label for="col9">Yderv√¶ggens materiale</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col10')">
<input id="col10" type="checkbox" value="Tagd√¶kningsmateriale"/>
<label for="col10">Tagd√¶kningsmateriale</label>
</div>

<div class="column-checkbox" onclick="toggleCheckbox('col11')">
<input id="col11" type="checkbox" value="Ejendomsnummer (BFE-nr.)"/>
<label for="col11">Ejendomsnummer (BFE-nr.)</label>
</div>
</div>
<h3 class="section-title" style="margin-top:16px;">Fejl og kvalitet</h3>
<p class="section-desc">Valgfrit: Tilf√∏j kolonner der hj√¶lper med at opdage fejl i PDF‚Äôen eller i udtr√¶kket.</p>
<div class="columns-grid" id="qualityColumnsGrid">
<div class="column-checkbox" onclick="toggleCheckbox('qWarn')">
<input id="qWarn" type="checkbox" value="_Warnings"/>
<label for="qWarn">Advarsler</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('qConf')">
<input id="qConf" type="checkbox" value="_Confidence"/>
<label for="qConf">P√•lidelighed (0-100)</label>
</div>
</div>
<div style="margin-top:10px;">
<label style="display:flex;align-items:center;gap:8px;">
<input id="debugConsole" type="checkbox"/>
<span>Vis detaljeret debug i konsollen (F12)</span>
</label>
</div>
</div>
<div class="upload-area" id="uploadArea">
<div class="upload-icon">üìÅ</div>
<div class="upload-text">Tr√¶k og slip PDF-filer her</div>
<div class="upload-subtext">eller klik for at v√¶lge filer</div>
</div>
<input accept=".pdf" id="fileInput" multiple="" type="file"/>
<div class="file-list" id="fileList"></div>
<button class="process-btn" disabled="" id="processBtn">
                Preview Data
            </button>
<div class="progress" id="progress">
<div class="progress-bar">
<div class="progress-fill" id="progressFill"></div>
</div>
<div class="progress-text" id="progressText"></div>
</div>
<div class="status" id="status"></div>
</div>
</div>
<!-- Preview Modal -->
<div class="modal" id="previewModal">
<div class="modal-content">
<div class="modal-header">
<h2>üìä Preview Data</h2>
<span class="modal-close" onclick="closePreview()">√ó</span>
</div>
<div class="modal-body">
<div class="sheet-tabs" id="sheetTabs"></div>
<div id="sheetContents"></div>
</div>
<div class="modal-footer">
<button class="modal-btn modal-btn-cancel" onclick="closePreview()">Luk</button>
<button class="modal-btn modal-btn-download" onclick="downloadExcel()">Download Excel</button>
</div>
</div>
</div>
<!-- PDF.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<!-- SheetJS for Excel generation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
        // Initialize PDF.js (guarded: many corporate networks block CDNs)
        // If pdfjsLib isn't available, we still want the UI/uploader to work and show a clear error on processing.
        if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        } else {
            console.warn('pdfjsLib not loaded. If you are on a corporate network, CDNs may be blocked.');
        }

        // State management
        let selectedFiles = [];
        let processedData = null; // Store processed data for preview and download

        // --- Text normalization (handles new PDF layout where letters/numbers are split with spaces) ---
        function normalizeText(raw) {
            if (!raw) return '';
            let t = raw;

            // Fix common unit split: "m 2" -> "m2"
            t = t.replace(/m\s+2/g, 'm2');

            // Merge spaced digits: "1 0 9 6" -> "1096"
            t = t.replace(/\b(?:\d\s+){1,}\d\b/g, (m) => m.replace(/\s+/g, ''));

            // Merge spaced letters for Danish alphabet (words split into single letters)
            // Example: "B y g n i n g e n s" -> "Bygningens"
            t = t.replace(/\b(?:[A-Za-z√Ü√ò√Ö√¶√∏√•]\s+){2,}[A-Za-z√Ü√ò√Ö√¶√∏√•]\b/g, (m) => m.replace(/\s+/g, ''));

            // Collapse multiple spaces/newlines
            t = t.replace(/\s+/g, ' ').trim();
            return t;
        }



        // Extract Ejendomsnummer (BFE-nr.) (property-level)
        function extractBFE(text) {
            if (!text) return undefined;
            // Try with spaces
            let m = text.match(/Ejendomsnummer\s*\(\s*BFE-?nr\.?\s*\)\s*:\s*(\d{6,})/i);
            if (m && m[1]) return m[1];

            // Try no-space variant (new layout can concatenate words)
            const ns = text.replace(/\s+/g, '');
            m = ns.match(/Ejendomsnummer\(BFE-?nr\.?\):(\d{6,})/i);
            if (m && m[1]) return m[1];

            return undefined;
        }
        // Column mapping - always include Bygningsnr. first
        const allColumns = [
            'Bygningsnr.',
            'Samlet bygningsareal',
            'Samlet k√¶lderareal',
            'Samlet tagetageareal',
            'Heraf udnyttet tagetage',
            'Samlet andet areal',
            'Bebygget areal'
        ];

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const processBtn = document.getElementById('processBtn');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');

        // Checkbox management
        function toggleCheckbox(id) {
            const ev = window.event;
            if (ev && ev.stopPropagation) ev.stopPropagation();
            const checkbox = document.getElementById(id);
            checkbox.checked = !checkbox.checked;
            updateCheckboxStyles();
            updateProcessButton();
        }

        function updateCheckboxStyles() {
            document.querySelectorAll('.column-checkbox').forEach(div => {
                const checkbox = div.querySelector('input[type="checkbox"]');
                if (checkbox.checked) {
                    div.classList.add('checked');
                } else {
                    div.classList.remove('checked');
                }
            });
        }

        function selectAll() {
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            updateCheckboxStyles();
            updateProcessButton();
        }

        function deselectAll() {
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            updateCheckboxStyles();
            updateProcessButton();
        }

        function getSelectedColumns() {
            const selected = ['Bygningsnr.']; // Always include building number
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    selected.push(cb.value);
                }
            });
            return selected;
        }

        // Initialize checkbox styles
        updateCheckboxStyles();

        // Upload area events
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            const pdfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.pdf'));
            selectedFiles = [...selectedFiles, ...pdfFiles];
            renderFileList();
            updateProcessButton();
        }

        function renderFileList() {
            if (selectedFiles.length === 0) {
                fileList.innerHTML = '';
                return;
            }

            fileList.innerHTML = selectedFiles.map((file, index) => `
                <div class="file-item">
                    <span class="file-name">üìÑ ${file.name}</span>
                    <span class="file-remove" onclick="removeFile(${index})">‚úï</span>
                </div>
            `).join('');
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFileList();
            updateProcessButton();
        }

        function updateProcessButton() {
            const hasSelectedColumns = document.querySelectorAll('.column-checkbox input[type="checkbox"]:checked').length > 0;
            processBtn.disabled = !hasSelectedColumns || selectedFiles.length === 0;
        }

        // Main processing function
        processBtn.addEventListener('click', async () => {
            try {
                if (!window.pdfjsLib) {
                    showStatus('error', 'PDF.js kunne ikke indl√¶ses. Det skyldes ofte at CDNs er blokeret p√• netv√¶rket (firma-sikkerhed).\n\nL√∏sning: Host pdf.min.js + pdf.worker.min.js sammen med siden (samme dom√¶ne) eller bed IT tillade cdnjs.cloudflare.com.');
                    return;
                }
                showStatus('info', 'Behandler PDFer...');
                showProgress(true);
                processBtn.disabled = true;

                const selectedColumns = getSelectedColumns();
                const allData = [];
                const grandTotals = [];

                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    updateProgress((i / selectedFiles.length) * 100, `Behandler ${file.name}...`);

                    const { buildings, sheetName } = await extractPDFData(file);
                    
                    // Filter columns based on user selection
                    const filteredBuildings = buildings.map(building => {
                        const filtered = {};
                        selectedColumns.forEach(col => {
                            filtered[col] = building[col] ||'';
                        });
                        return filtered;
                    });

                    // Calculate totals for this sheet (only from non-empty buildings)
                    const totalRow = {};
                    totalRow['Bygningsnr.'] = sheetName;
                    
                    selectedColumns.forEach(col => {
                        if (col === 'Bygningsnr.') return;

                        // Only sum real area columns. "Anden data" + quality columns should NOT be summed.
                        if (typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(col)) {
                            const sum = filteredBuildings.reduce((acc, b) => {
                                const v = b[col];
                                const val = (typeof v === 'number') ? v : (parseInt(v, 10) || 0);
                                return acc + val;
                            }, 0);
                            totalRow[col] = sum;
                            return;
                        }

                        // Quality columns
                        if (col === '_Confidence') {
                            const vals = filteredBuildings
                                .map(b => (typeof b[col] === 'number' ? b[col] : parseInt(b[col], 10)))
                                .filter(v => typeof v === 'number' && !isNaN(v));
                            totalRow[col] = vals.length ? Math.round(vals.reduce((a, x) => a + x, 0) / vals.length) : '-';
                            return;
                        }
                        if (col === '_Warnings') {
                            totalRow[col] = '-';
                            return;
                        }

                        // Anden data / text columns: do not sum
                        totalRow[col] = '-';
                    });

                    // Calculate row total
                    const rowTotal = Object.keys(totalRow)
                        .filter(k => k !== 'Bygningsnr.' && k !== 'Total')
                        .reduce((acc, k) => acc + ((typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(k)) ? (parseInt(totalRow[k], 10) || 0) : 0), 0);
                    totalRow['Total'] = rowTotal;

                    grandTotals.push(totalRow);

                    // Add total row to buildings
                    filteredBuildings.push(totalRow);

                    allData.push({
                        sheetName: sheetName,
                        data: filteredBuildings
                    });
                }

                updateProgress(95, 'Forbereder preview...');

                // Create grand total sheet
                const finalTotalRow = {};
                finalTotalRow['Bygningsnr.'] = 'Final Total';
                
                selectedColumns.forEach(col => {
                    if (col === 'Bygningsnr.') return;

                    if (typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(col)) {
                        const sum = grandTotals.reduce((acc, row) => acc + (parseInt(row[col], 10) || 0), 0);
                        finalTotalRow[col] = sum;
                        return;
                    }

                    if (col === '_Confidence') {
                        const vals = grandTotals
                            .map(r => (typeof r[col] === 'number' ? r[col] : parseInt(r[col], 10)))
                            .filter(v => typeof v === 'number' && !isNaN(v));
                        finalTotalRow[col] = vals.length ? Math.round(vals.reduce((a, x) => a + x, 0) / vals.length) : '-';
                        return;
                    }

                    if (col === '_Warnings') {
                        finalTotalRow[col] = '-';
                        return;
                    }

                    finalTotalRow[col] = '-';
                });

                const finalRowTotal = Object.keys(finalTotalRow)
                    .filter(k => k !== 'Bygningsnr.' && k !== 'Total')
                    .reduce((acc, k) => acc + ((typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(k)) ? (parseInt(finalTotalRow[k], 10) || 0) : 0), 0);
                finalTotalRow['Total'] = finalRowTotal;

                grandTotals.push(finalTotalRow);

                // Store data globally
                processedData = {
                    allData: allData,
                    grandTotals: grandTotals,
                    selectedColumns: selectedColumns
                };

                updateProgress(100, 'F√¶rdig!');
                showStatus('success', `‚úì Data behandlet! ${selectedFiles.length} PDFer klar til preview.`);
                
                setTimeout(() => {
                    showProgress(false);
                    processBtn.disabled = false;
                    showPreview();
                }, 500);

            } catch (error) {
                console.error('Error:', error);
                showStatus('error', 'Fejl: ' + error.message);
                showProgress(false);
                processBtn.disabled = false;
            }
        });

        async function extractPDFData(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            let allText = '';
            
            // Extract text from all pages
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                let pageText = textContent.items.map(item => item.str).join(' ');
                pageText = normalizeText(pageText);
                allText += pageText + '\n';
            }

            // Extract sheet name (BBR address)
            let sheetName = 'Unknown';

            // In newer BBR PDFs the address often appears as "BBR-adresse: <vejnavn> <nr>, <postnr> <by>"
            // We only want the short street + number for the tab name (e.g. "Seminarievej 23")
            const addrPatterns = [
              /BBR[-\s]?adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|\s+Postnr\.|\s+By\b|$)/i,
              /Oplysninger\s*om\s*grund\s*Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /Oplysningeromgrund\s*Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /BeliggenhedAdresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i
            ];

            for (const pat of addrPatterns) {
              const m = allText.match(pat);
              if (m && m[1]) {
                sheetName = m[1].replace(/\s+/g, ' ').trim();
                break;
              }
            }

            // Keep tab names reasonably short and Excel-friendly
            sheetName = sheetName.replace(/[\\/:\?\*\[\]]/g, '').trim();
            if (sheetName.length > 60) sheetName = sheetName.slice(0, 60).trim();

            // Parse building data
            const bfe = extractBFE(allText);

            // Parse building data
            const buildings = parseBuildings(allText, { bfe });

            return { buildings, sheetName };
        }

        
        function parseBuildings(text, meta) {
            const buildings = [];

            // Collect building markers from both old and new layouts
            // Old: "Bygningsnr.: 7"
            // New: "Bygning 7"
            const markers = [];
            const reOld = /Bygningsnr\.\s*:\s*(\d+)/g;
            const reNew = /\bBygning\s+(\d+)\b/g;

            let m;
            while ((m = reOld.exec(text)) !== null) {
                markers.push({ num: parseInt(m[1], 10), pos: m.index });
            }
            while ((m = reNew.exec(text)) !== null) {
                markers.push({ num: parseInt(m[1], 10), pos: m.index });
            }

            // sort by position and dedupe near-duplicates
            markers.sort((a, b) => a.pos - b.pos);
            const deduped = [];
            for (const mk of markers) {
                const last = deduped[deduped.length - 1];
                if (last && last.num === mk.num && Math.abs(last.pos - mk.pos) < 80) continue;
                deduped.push(mk);
            }

            const debugOn = document.getElementById('debugConsole')?.checked;
            if (debugOn) {
                console.log('=== PARSE DEBUG ===');
                console.log('Building markers found:', deduped.map(b => b.num));
            }

            function matchFirstNumber(section, patterns) {
                for (const pat of patterns) {
                    const mm = section.match(pat);
                    if (mm && mm[1] !== undefined) return parseInt(mm[1], 10);
                }
                return undefined;
            }

            function matchTextField(section, patterns) {
                for (const pat of patterns) {
                    const mm = section.match(pat);
                    if (mm && mm[1]) {
                        let v = mm[1].trim();
                        // Cut off if the capture accidentally includes the next label (new PDF layout often concatenates words)
                        const stopTokens = [
                            'supplerendeyderv√¶gsmateriale',
                            'supplerendetagd√¶kningsmateriale',
                            'varmeforsyning',
                            'bygningensvarmeinstallation',
                            'opvarmningsmiddel',
                            'energiplan',
                            'ejerforhold',
                            'kildetil',
                            'bbr-meddelelse',
                            'udskriftsdato',
                            'side'
                        ];
                        const vLower = v.toLowerCase();
                        let cutIdx = v.length;
                        for (const tok of stopTokens) {
                            const j = vLower.indexOf(tok);
                            if (j !== -1 && j < cutIdx) cutIdx = j;
                        }
                        v = v.slice(0, cutIdx).trim();
                        // remove trailing punctuation
                        v = v.replace(/[\s,;:.-]+$/g, '').trim();
                        return v || undefined;
                    }
                }
                return undefined;
            }

            function pickClosestYear(section, anchorIdxInSection) {
                // Prefer "Sikker Opf√∏relses√•r" then "Opf√∏relses√•r"
                const yearMatches = [];
                const yrRe = /(Sikker\s+Opf√∏relses√•r|Opf√∏relses√•r)\s*:\s*(\d{4})/gi;
                let ym;
                while ((ym = yrRe.exec(section)) !== null) {
                    yearMatches.push({ label: ym[1], year: parseInt(ym[2], 10), idx: ym.index });
                }
                if (!yearMatches.length) return undefined;

                // Prefer matches BEFORE anchor, closest distance; else closest after
                let best = null;
                for (const y of yearMatches) {
                    const dist = y.idx - anchorIdxInSection;
                    const score = (dist <= 0 ? Math.abs(dist) : 100000 + dist) + (String(y.label).toLowerCase().includes('sikker') ? -50 : 0);
                    if (!best || score < best.score) best = { ...y, score };
                }
                return best ? best.year : undefined;
            }

                        // Pre-scan Bebygget areal in the FULL text and assign each match to the nearest building marker
            // by looking for the last "Bygning X" / "Bygningsnr.: X" within a window before the match.
            const bebyggetByBuilding = new Map();
            const bebyggetMatches = [];
            const bebyggetRe = /(Bebygget\s*areal|Bebyggetareal)\s*(?::|\s)\s*(\d{1,6})(?:\s*(?:m2|m¬≤))?/gi;
            let bm;
            while ((bm = bebyggetRe.exec(text)) !== null) {
                bebyggetMatches.push({ idx: bm.index, val: parseInt(bm[2], 10) });
            }
            for (const b of bebyggetMatches) {
                const lookBackStart = Math.max(0, b.idx - 900);
                const windowText = text.substring(lookBackStart, b.idx);
                let owner = null;

                // find LAST marker in the lookback window
                const markerRe = /(Bygningsnr\.\s*:\s*(\d+))|\bBygning\s+(\d+)\b/gi;
                let mm;
                while ((mm = markerRe.exec(windowText)) !== null) {
                    owner = parseInt(mm[2] || mm[3], 10);
                }

                if (owner !== null && !Number.isNaN(owner)) {
                    // If multiple values map to same building, keep the one closest to its marker later (overwrite is fine).
                    bebyggetByBuilding.set(owner, b.val);
                }
            }

for (let i = 0; i < deduped.length; i++) {
                const cur = deduped[i];
                const prev = deduped[i - 1];
                const next = deduped[i + 1];

                const startPos = prev ? Math.floor((prev.pos + cur.pos) / 2) : 0;
                const endPos = next ? Math.floor((cur.pos + next.pos) / 2) : text.length;
                const section = text.substring(startPos, endPos);

                const anchorIdx = cur.pos - startPos;

                const building = { 'Bygningsnr.': cur.num };

                // Property-level field (same for all buildings)
                if (meta && meta.bfe) building['Ejendomsnummer (BFE-nr.)'] = meta.bfe;


                // --- Areal-felter (old + new labels) ---
                building['Samlet bygningsareal'] = matchFirstNumber(section, [
                    /Samlet bygningsareal[^\d]{0,40}(\d{1,6})/i,
                    /Samletbygningsareal[^\d]{0,40}(\d{1,6})/i,
                    /Bygningens samlede etageareal[^\d]{0,40}(\d{1,6})/i,
                    /Bygningenssamledeetageareal[^\d]{0,40}(\d{1,6})/i,
                ]);

                building['Samlet k√¶lderareal'] = matchFirstNumber(section, [
                    /Samlet k√¶lderareal[^\d]{0,30}(\d{1,6})/i,
                    /Samletk√¶lderareal[^\d]{0,30}(\d{1,6})/i,
                    /K√¶lderens areal[^\d]{0,30}(\d{1,6})/i,
                    /K√¶lderensareal[^\d]{0,30}(\d{1,6})/i,
                ]);

                building['Samlet tagetageareal'] = matchFirstNumber(section, [
                    /Samlet tagetageareal[^\d]{0,30}(\d{1,6})/i,
                    /Samlettagetageareal[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagens areal[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagensareal[^\d]{0,30}(\d{1,6})/i,
                    /Etagerens areal[^\d]{0,30}(\d{1,6})/i,
                    /Etagerensareal[^\d]{0,30}(\d{1,6})/i,
                ]);

                building['Heraf udnyttet tagetage'] = matchFirstNumber(section, [
                    /Heraf udnyttet tagetage[^\d]{0,30}(\d{1,6})/i,
                    /Herafudnyttettagetage[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagens udnyttede areal[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagensudnyttedeareal[^\d]{0,30}(\d{1,6})/i,
                    /heraf\s*Tagetagens\s*udnyttede\s*areal[^\d]{0,30}(\d{1,6})/i,
                    /herafTagetagensudnyttedeareal[^\d]{0,30}(\d{1,6})/i,
                ]);

                // Strict: avoid picking the "2" in "m2"
                const andet = section.match(/Samlet andet areal\s*:\s*(\d{1,6})(?!\s*(?:m2|m¬≤))/i);
                if (andet) building['Samlet andet areal'] = parseInt(andet[1], 10);

                                // Bebygget areal (new layout can be out-of-order). Prefer the pre-scanned mapping,
                // otherwise fall back to matching inside this building section.
                if (bebyggetByBuilding.has(cur.num)) {
                    building['Bebygget areal'] = bebyggetByBuilding.get(cur.num);
                } else {
                    const beb = section.match(/Bebygget\s*areal\s*:\s*(\d{1,6})(?:\s*(?:m2|m¬≤))?/i)
                             || section.match(/Bebygget\s*areal\s+(\d{1,6})(?:\s*(?:m2|m¬≤))?/i)
                             || section.match(/Bebyggetareal\s*:\s*(\d{1,6})(?:\s*(?:m2|m¬≤))?/i)
                             || section.match(/Bebyggetareal\s+(\d{1,6})(?:\s*(?:m2|m¬≤))?/i);
                    if (beb) building['Bebygget areal'] = parseInt(beb[1], 10);
                }

                // If other areal fields exist, bebygget is fallback
                const hasOtherAreal = ['Samlet bygningsareal','Samlet k√¶lderareal','Samlet tagetageareal','Heraf udnyttet tagetage','Samlet andet areal']
                    .some(k => building[k] !== undefined);
                if (hasOtherAreal && building['Bebygget areal'] !== undefined) {
                    delete building['Bebygget areal'];
                }

// --- Anden data ---
                building['Opf√∏relses√•r'] = pickClosestYear(section, anchorIdx);

                building['Antal etager u. k√¶lder & tagetage'] = matchFirstNumber(section, [
                    // Gammel label (med mellemrum)
                    /Antal etager u\.\s*k√¶lder\s*&\s*tagetage[^\d]{0,20}(\d{1,2})/i,
                    /Antal etager[^\d]{0,20}(\d{1,2})/i,
                    // Ny layout / normaliseret tekst (uden mellemrum)
                    /Antaletageru\.?(?:kaelder|k√¶lder)\s*&\s*tagetage[^\d]{0,20}(\d{1,2})/i,
                    /Antaletager[^\d]{0,20}(\d{1,2})/i,
                ]);

                building['Yderv√¶ggens materiale'] = matchTextField(section, [
                    /Yderv√¶ggens materiale\s*:\s*([^]+?)(?=\s{2,}|Tagd√¶kningsmateriale|Varmeinstallation|Energiplan|$)/i,
                    /Yderv√¶gsmateriale\s*:\s*([^]+?)(?=\s{2,}|Tagd√¶kningsmateriale|Varmeinstallation|Energiplan|$)/i,
                ]);

                building['Tagd√¶kningsmateriale'] = matchTextField(section, [
                    /Tagd√¶kningsmateriale\s*:\s*([^]+?)(?=\s{2,}|Varmeinstallation|Energiplan|$)/i,
                ]);

                // --- Quality ---
                const warnOn = document.getElementById('qWarn')?.checked;
                const confOn = document.getElementById('qConf')?.checked;

                if (warnOn || confOn) {
                    const warnings = [];
                    let conf = 100;

                    const arealKeys = ['Samlet bygningsareal','Samlet k√¶lderareal','Samlet tagetageareal','Heraf udnyttet tagetage','Samlet andet areal'];
                    const foundAreal = arealKeys.some(k => building[k] !== undefined);
                    if (!foundAreal && building['Bebygget areal'] === undefined) {
                        warnings.push('Ingen areal-felter fundet');
                        conf = Math.min(conf, 50);
                    }
                    if (!foundAreal && building['Bebygget areal'] !== undefined) {
                        warnings.push('Kun "Bebygget areal" fundet (fallback)');
                        conf = Math.min(conf, 80);
                    }

                    if (warnOn) building['_Warnings'] = warnings.length ? warnings.join(' | ') : '-';
                    if (confOn) building['_Confidence'] = conf;
                }

                if (debugOn) {
                    console.log(`Building ${cur.num} (block length: ${section.length}):`);
                    console.log(`First 260 chars: ${section.substring(0, 260)}`);
                }

                buildings.push(building);
            }

            
            // Dedupe: the new layout sometimes contains repeated "Bygning X" markers.
            // Keep/merge the entry with the most extracted fields and drop empty duplicates.
            const byNum = new Map();

            function valueIsPresent(v) {
                if (v === undefined || v === null) return false;
                if (typeof v === 'string') {
                    const t = v.trim();
                    return t !== '' && t !== '-' && t.toLowerCase() !== 'unknown';
                }
                if (typeof v === 'number') {
                    // Treat 0 as "not present" for these extracted fields (0s are usually artifacts)
                    return v > 0;
                }
                return false;
            }

            function scoreBuilding(b) {
                let s = 0;
                for (const [k, v] of Object.entries(b)) {
                    if (k === 'Bygningsnr.') continue;
                    if (k.startsWith('_')) continue;
                    if (valueIsPresent(v)) s += 1;
                }
                return s;
            }

            for (const b of buildings) {
                const num = b['Bygningsnr.'];
                const sc = scoreBuilding(b);
                if (!byNum.has(num)) {
                    if (sc > 0) byNum.set(num, { b, sc });
                    else byNum.set(num, { b, sc }); // keep for now; may be replaced by a better one later
                    continue;
                }
                const cur = byNum.get(num);

                // Pick primary (higher score)
                let primary = cur.b, secondary = b;
                let pScore = cur.sc, sScore = sc;
                if (sScore > pScore) {
                    primary = b; secondary = cur.b;
                    pScore = sScore; sScore = cur.sc;
                }

                // Merge: fill missing fields in primary from secondary
                for (const [k, v] of Object.entries(secondary)) {
                    if (k === 'Bygningsnr.') continue;
                    if (!valueIsPresent(primary[k]) && valueIsPresent(v)) {
                        primary[k] = v;
                    }
                }

                byNum.set(num, { b: primary, sc: scoreBuilding(primary) });
            }

            // Drop entries that still have no extracted fields at all
            const out = Array.from(byNum.values())
                .map(x => x.b)
                .filter(b => scoreBuilding(b) > 0)
                .sort((a, b) => a['Bygningsnr.'] - b['Bygningsnr.']);

            return out;

        }

        function showStatus(type, message) {
            status.className = 'status ' + type;
            status.textContent = message;
        }

        function showProgress(show) {
            progress.style.display = show ? 'block' : 'none';
            if (!show) {
                progressFill.style.width = '0%';
            }
        }

        function updateProgress(percent, text) {
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
        }

        // Preview Modal Functions
        function showPreview() {
            if (!processedData) return;

            const modal = document.getElementById('previewModal');
            const tabsContainer = document.getElementById('sheetTabs');
            const contentsContainer = document.getElementById('sheetContents');

            // Clear previous content
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';

            // Create tabs and content for each sheet
            processedData.allData.forEach((sheet, index) => {
                // Create tab
                const tab = document.createElement('button');
                tab.className = 'sheet-tab' + (index === 0 ? ' active' : '');
                tab.textContent = sheet.sheetName;
                tab.onclick = () => switchTab(index);
                tabsContainer.appendChild(tab);

                // Create content
                const content = document.createElement('div');
                content.className = 'sheet-content' + (index === 0 ? ' active' : '');
                content.id = 'sheet-' + index;
                content.innerHTML = generateTableHTML(sheet.data, processedData.selectedColumns, sheet.name);
                contentsContainer.appendChild(content);
            });

            // Add Grand Total tab
            const grandTab = document.createElement('button');
            grandTab.className = 'sheet-tab';
            grandTab.textContent = 'Grand Total';
            grandTab.onclick = () => switchTab(processedData.allData.length);
            tabsContainer.appendChild(grandTab);

            const grandContent = document.createElement('div');
            grandContent.className = 'sheet-content';
            grandContent.id = 'sheet-' + processedData.allData.length;
            grandContent.innerHTML = generateTableHTML(processedData.grandTotals, processedData.selectedColumns, 'Grand Total');
            contentsContainer.appendChild(grandContent);

            modal.classList.add('show');
        }

        function closePreview() {
            const modal = document.getElementById('previewModal');
            modal.classList.remove('show');
        }

        function switchTab(index) {
            // Update tab styles
            document.querySelectorAll('.sheet-tab').forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Update content visibility
            document.querySelectorAll('.sheet-content').forEach((content, i) => {
                if (i === index) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
        }

        
        const ANDEN_DATA_COLS = new Set([
            'Opf√∏relses√•r',
            'Antal etager u. k√¶lder & tagetage',
            'Yderv√¶ggens materiale',
            'Tagd√¶kningsmateriale',
            'Ejendomsnummer (BFE-nr.)'
        ]);

        const QUALITY_COLS = new Set(['_Warnings','_Confidence']);

        const SUMMABLE_COLS = new Set([
            'Samlet bygningsareal',
            'Samlet k√¶lderareal',
            'Samlet tagetageareal',
            'Heraf udnyttet tagetage',
            'Samlet andet areal',
            'Bebygget areal'
        ]);

        function generateTableHTML(data, columns, sheetName) {
            if (!data || data.length === 0) {
                return '<p>Ingen data</p>';
            }

            // Hide "Anden data" columns in Grand Total
            let cols = columns.slice();
            if (sheetName === 'Grand Total') {
                cols = cols.filter(c => !ANDEN_DATA_COLS.has(c));
            }

            // Order: base cols, Total, then Anden data cols (and quality cols last)
            const andenCols = cols.filter(c => ANDEN_DATA_COLS.has(c));
            const qualityCols = cols.filter(c => QUALITY_COLS.has(c));
            const baseCols = cols.filter(c => !ANDEN_DATA_COLS.has(c) && !QUALITY_COLS.has(c));

            let html = '<table class="preview-table"><thead><tr>';

            baseCols.forEach(col => { html += `<th>${col}</th>`; });
            html += '<th>Total (row sum)</th>';
            andenCols.forEach(col => { html += `<th>${col}</th>`; });
            qualityCols.forEach(col => { html += `<th>${col}</th>`; });

            html += '</tr></thead><tbody>';

            data.forEach((row, index) => {
                const isTotal = index === data.length - 1 || typeof row['Bygningsnr.'] === 'string';
                const rowClass = isTotal ? 'total-row' : '';

                let rowSum = 0;
                baseCols.forEach(col => {
                    if (SUMMABLE_COLS.has(col)) {
                        const val = row[col];
                        if (typeof val === 'number' && !isNaN(val)) rowSum += val;
                    }
                });

                html += `<tr class="${rowClass}">`;

                baseCols.forEach(col => {
                    let val = row[col];
                    if (val === undefined || val === null || val === '') val = '-';
                    html += `<td>${val}</td>`;
                });

                html += `<td class="row-total">${rowSum}</td>`;

                andenCols.forEach(col => {
                    let val = row[col];
                    if (isTotal) val = '-';
                    if (val === undefined || val === null || val === '') val = '-';
                    html += `<td>${val}</td>`;
                });

                qualityCols.forEach(col => {
                    let val = row[col];
                    if (val === undefined || val === null || val === '') val = '-';
                    html += `<td>${val}</td>`;
                });

                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        function downloadExcel() {
            if (!processedData) return;

            // Generate Excel file
            const wb = XLSX.utils.book_new();

            // Add individual sheets
            processedData.allData.forEach(sheet => {
                const ws = XLSX.utils.json_to_sheet(sheet.data);
                XLSX.utils.book_append_sheet(wb, ws, sheet.sheetName.substring(0, 31));
            });

            // Add grand total sheet
            const grandTotalWs = XLSX.utils.json_to_sheet(processedData.grandTotals);
            XLSX.utils.book_append_sheet(wb, grandTotalWs, 'Grand Total');

            // Download file
            XLSX.writeFile(wb, 'bbr_data.xlsx');

            showStatus('success', '‚úì Excel fil downloadet!');
            closePreview();
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('previewModal');
            if (event.target === modal) {
                closePreview();
            }
        }
    </script>
</body>
</html>
