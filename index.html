<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBR PDF Data Ekstraktor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .column-selection {
            margin-bottom: 30px;
        }

        .column-selection > label {
            display: block;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            font-size: 1.1rem;
        }

        .columns-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .column-checkbox {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .column-checkbox:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .column-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .column-checkbox label {
            cursor: pointer;
            font-size: 1rem;
            color: #333;
            user-select: none;
            flex: 1;
        }

        .column-checkbox.checked {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .quick-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quick-btn {
            padding: 8px 16px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s;
        }

        .quick-btn:hover {
            background: #667eea;
            color: white;
        }

        .upload-area {
            border: 3px dashed #d0d0d0;
            border-radius: 12px;
            padding: 50px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2rem;
            color: #555;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #888;
            font-size: 0.95rem;
        }

        #fileInput {
            display: none;
        }

        .file-list {
            margin-top: 25px;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .file-name {
            font-weight: 500;
            color: #333;
        }

        .file-remove {
            color: #ff4444;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px;
        }

        .file-remove:hover {
            color: #cc0000;
        }

        .process-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .process-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            display: block;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
            display: block;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            display: block;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 0.95rem;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.8rem;
            }

            .card {
                padding: 25px;
            }

            .insurance-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* Preview Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow: auto;
        }

        .modal.show {
            display: block;
        }

        .modal-content {
            background-color: white;
            margin: 20px auto;
            padding: 0;
            width: 95%;
            max-width: 1200px;
            border-radius: 12px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .modal-close {
            font-size: 2rem;
            cursor: pointer;
            color: white;
            line-height: 1;
            padding: 0 10px;
        }

        .modal-close:hover {
            opacity: 0.7;
        }

        .modal-body {
            padding: 20px 30px;
            overflow-y: auto;
            flex: 1;
        }

        .sheet-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .sheet-tab {
            padding: 10px 20px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .sheet-tab:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .sheet-tab.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .sheet-content {
            display: none;
        }

        .sheet-content.active {
            display: block;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.95rem;
        }

        .preview-table th {
            background: #f5f5f5;
            padding: 12px 10px;
            text-align: left;
            border: 1px solid #ddd;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .preview-table td {
            padding: 10px;
            border: 1px solid #ddd;
        }

        .preview-table tr:nth-child(even) {
            background: #fafafa;
        }

        .preview-table tr:hover {
            background: #f0f4ff;
        }

        .preview-table .total-row {
            background: #e3f2fd !important;
            font-weight: 600;
        }

        .modal-footer {
            padding: 20px 30px;
            border-top: 2px solid #e0e0e0;
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-btn-cancel {
            background: #e0e0e0;
            color: #333;
        }

        .modal-btn-cancel:hover {
            background: #d0d0d0;
        }

        .modal-btn-download {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modal-btn-download:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
    
        .meta-selection {
            margin-top: 18px;
            padding-top: 14px;
            border-top: 1px solid #e5e7eb;
        }
        .meta-title {
            font-weight: 700;
            margin-bottom: 4px;
            color: #333;
        }
        .meta-desc {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 10px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ BBR PDF Data Ekstraktor</h1>
            <p>Upload BBR PDFer og f√• data i Excel format</p>
        </div>

        <div class="card">
            <div class="column-selection">
                <label>V√¶lg hvilke kolonner du vil have i Excel:</label>
                
                <div class="quick-select">
                    <button class="quick-btn" onclick="selectAll()">V√¶lg alle</button>
                    <button class="quick-btn" onclick="deselectAll()">Frav√¶lg alle</button>
                    <button class="quick-btn" onclick="selectABCE()">ABCE profil</button>
                    <button class="quick-btn" onclick="selectABD()">ABD profil</button>
                </div>

                <div class="columns-grid" id="columnsGrid">
                    <div class="column-checkbox" onclick="toggleCheckbox('col1')">
                        <input type="checkbox" id="col1" value="Samlet bygningsareal" checked>
                        <label for="col1">Samlet bygningsareal</label>
                    </div>
                    <div class="column-checkbox" onclick="toggleCheckbox('col2')">
                        <input type="checkbox" id="col2" value="Samlet k√¶lderareal" checked>
                        <label for="col2">Samlet k√¶lderareal</label>
                    </div>
                    <div class="column-checkbox" onclick="toggleCheckbox('col3')">
                        <input type="checkbox" id="col3" value="Samlet tagetageareal" checked>
                        <label for="col3">Samlet tagetageareal</label>
                    </div>
                    <div class="column-checkbox" onclick="toggleCheckbox('col4')">
                        <input type="checkbox" id="col4" value="Heraf udnyttet tagetage">
                        <label for="col4">Heraf udnyttet tagetage</label>
                    </div>
                    <div class="column-checkbox" onclick="toggleCheckbox('col5')">
                        <input type="checkbox" id="col5" value="Samlet andet areal" checked>
                        <label for="col5">Samlet andet areal</label>
                    </div>
                    <div class="column-checkbox" onclick="toggleCheckbox('col6')">
                        <input type="checkbox" id="col6" value="Bebygget areal" checked>
                        <label for="col6">Bebygget areal (bruges kun hvis andre ikke er udfyldt)</label>
                    </div>
                </div>

                <div class="meta-selection">
                    <div class="meta-title">Ekstra kolonner (valgfrit)</div>
                    <div class="meta-desc">Vis en vurdering af hvor sikkert data er udtrukket, og evt. advarsler hvis noget ser m√¶rkeligt ud.</div>
                    <div class="columns-grid">
                        <div class="column-checkbox" onclick="toggleCheckbox('col7')">
                            <input type="checkbox" id="col7" value="_Confidence" checked>
                            <label for="col7">P√•lidelighed (0-100)</label>
                        </div>
                        <div class="column-checkbox" onclick="toggleCheckbox('col8')">
                            <input type="checkbox" id="col8" value="_Warnings" checked>
                            <label for="col8">Advarsler</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">Tr√¶k og slip PDF-filer her</div>
                <div class="upload-subtext">eller klik for at v√¶lge filer</div>
            </div>

            <input type="file" id="fileInput" multiple accept=".pdf">

            <div class="file-list" id="fileList"></div>

            <button class="process-btn" id="processBtn" disabled>
                Preview Data
            </button>

            <div class="progress" id="progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText"></div>
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="previewModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìä Preview Data</h2>
                <span class="modal-close" onclick="closePreview()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="sheet-tabs" id="sheetTabs"></div>
                <div id="sheetContents"></div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-cancel" onclick="closePreview()">Luk</button>
                <button class="modal-btn modal-btn-download" onclick="downloadExcel()">Download Excel</button>
            </div>
        </div>
    </div>

    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- SheetJS for Excel generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State management
        let selectedFiles = [];
        let processedData = null; // Store processed data for preview and download

        // Column mapping - always include Bygningsnr. first
        const allColumns = [
            'Bygningsnr.',
            'Samlet bygningsareal',
            'Samlet k√¶lderareal',
            'Samlet tagetageareal',
            'Heraf udnyttet tagetage',
            'Samlet andet areal',
            'Bebygget areal'
        ];

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const processBtn = document.getElementById('processBtn');
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');

        // Checkbox management
        function toggleCheckbox(id) {
            event.stopPropagation();
            const checkbox = document.getElementById(id);
            checkbox.checked = !checkbox.checked;
            updateCheckboxStyles();
            updateProcessButton();
        }

        function updateCheckboxStyles() {
            document.querySelectorAll('.column-checkbox').forEach(div => {
                const checkbox = div.querySelector('input[type="checkbox"]');
                if (checkbox.checked) {
                    div.classList.add('checked');
                } else {
                    div.classList.remove('checked');
                }
            });
        }

        function selectAll() {
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            updateCheckboxStyles();
            updateProcessButton();
        }

        function deselectAll() {
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            updateCheckboxStyles();
            updateProcessButton();
        }

        function selectABCE() {
            deselectAll();
            // ABCE: Samlet bygningsareal, Samlet k√¶lderareal, Samlet tagetageareal, Samlet andet areal, Bebygget areal
            document.getElementById('col1').checked = true;
            document.getElementById('col2').checked = true;
            document.getElementById('col3').checked = true;
            document.getElementById('col5').checked = true;
            document.getElementById('col6').checked = true;
            updateCheckboxStyles();
            updateProcessButton();
        }

        function selectABD() {
            deselectAll();
            // ABD: Samlet bygningsareal, Samlet k√¶lderareal, Heraf udnyttet tagetage, Bebygget areal
            document.getElementById('col1').checked = true;
            document.getElementById('col2').checked = true;
            document.getElementById('col4').checked = true;
            document.getElementById('col6').checked = true;
            updateCheckboxStyles();
            updateProcessButton();
        }

        function getSelectedColumns() {
            const selected = ['Bygningsnr.']; // Always include building number
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    selected.push(cb.value);
                }
            });
            return selected;
        }

        // Initialize checkbox styles
        updateCheckboxStyles();

        // Upload area events
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            const pdfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.pdf'));
            selectedFiles = [...selectedFiles, ...pdfFiles];
            renderFileList();
            updateProcessButton();
        }

        function renderFileList() {
            if (selectedFiles.length === 0) {
                fileList.innerHTML = '';
                return;
            }

            fileList.innerHTML = selectedFiles.map((file, index) => `
                <div class="file-item">
                    <span class="file-name">üìÑ ${file.name}</span>
                    <span class="file-remove" onclick="removeFile(${index})">‚úï</span>
                </div>
            `).join('');
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFileList();
            updateProcessButton();
        }

        function updateProcessButton() {
            const hasSelectedColumns = document.querySelectorAll('.column-checkbox input[type="checkbox"]:checked').length > 0;
            processBtn.disabled = !hasSelectedColumns || selectedFiles.length === 0;
        }

        // Main processing function
        processBtn.addEventListener('click', async () => {
            try {
                showStatus('info', 'Behandler PDFer...');
                showProgress(true);
                processBtn.disabled = true;

                const selectedColumns = getSelectedColumns();
                const allData = [];
                const grandTotals = [];

                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    updateProgress((i / selectedFiles.length) * 100, `Behandler ${file.name}...`);

                    const { buildings, sheetName } = await extractPDFData(file);
                    
                    // Filter columns based on user selection
                    const filteredBuildings = buildings.map(building => {
                        const filtered = {};
                        selectedColumns.forEach(col => {
                            filtered[col] = (building[col] ?? '');
                        });
                        return filtered;
                    });

                    // Calculate totals for this sheet (only from non-empty buildings)
                    const totalRow = {};
                    totalRow['Bygningsnr.'] = sheetName;
                    
                    selectedColumns.forEach(col => {
                        if (col === 'Bygningsnr.') return;

                        // Meta columns
                        if (col === '_Warnings') {
                            totalRow[col] = '';
                            return;
                        }
                        if (col === '_Confidence') {
                            let sum = 0;
                            let count = 0;
                            filteredBuildings.forEach(b => {
                                const v = parseInt(b[col]);
                                if (!isNaN(v)) { sum += v; count++; }
                            });
                            totalRow[col] = count ? Math.round(sum / count) : '';
                            return;
                        }

                        const sum = filteredBuildings.reduce((acc, b) => {
                            const val = parseInt(b[col]) || 0;
                            return acc + val;
                        }, 0);
                        totalRow[col] = sum;
                    });

                    // Calculate row total
                    const rowTotal = Object.keys(totalRow)
                        .filter(k => k !== 'Bygningsnr.' && k !== 'Total' && !k.startsWith('_'))
                        .reduce((acc, k) => acc + (parseInt(totalRow[k]) || 0), 0);
                    totalRow['Total'] = rowTotal;

                    grandTotals.push(totalRow);

                    // Add total row to buildings
                    filteredBuildings.push(totalRow);

                    allData.push({
                        sheetName: sheetName,
                        data: filteredBuildings
                    });
                }

                updateProgress(95, 'Forbereder preview...');

                // Create grand total sheet
                const finalTotalRow = {};
                finalTotalRow['Bygningsnr.'] = 'Final Total';
                
                selectedColumns.forEach(col => {
                        if (col === 'Bygningsnr.') return;

                        if (col === '_Warnings') {
                            finalTotalRow[col] = '';
                            return;
                        }
                        if (col === '_Confidence') {
                            let sum = 0;
                            let count = 0;
                            grandTotals.forEach(r => {
                                const v = parseInt(r[col]);
                                if (!isNaN(v)) { sum += v; count++; }
                            });
                            finalTotalRow[col] = count ? Math.round(sum / count) : '';
                            return;
                        }

                        const sum = grandTotals.reduce((acc, row) => acc + (parseInt(row[col]) || 0), 0);
                        finalTotalRow[col] = sum;
                    });

                const finalRowTotal = Object.keys(finalTotalRow)
                    .filter(k => k !== 'Bygningsnr.' && k !== 'Total' && !k.startsWith('_'))
                    .reduce((acc, k) => acc + (parseInt(finalTotalRow[k]) || 0), 0);
                finalTotalRow['Total'] = finalRowTotal;

                grandTotals.push(finalTotalRow);

                // Store data globally
                processedData = {
                    allData: allData,
                    grandTotals: grandTotals,
                    selectedColumns: selectedColumns
                };

                updateProgress(100, 'F√¶rdig!');
                showStatus('success', `‚úì Data behandlet! ${selectedFiles.length} PDFer klar til preview.`);
                
                setTimeout(() => {
                    showProgress(false);
                    processBtn.disabled = false;
                    showPreview();
                }, 500);

            } catch (error) {
                console.error('Error:', error);
                showStatus('error', 'Fejl: ' + error.message);
                showProgress(false);
                processBtn.disabled = false;
            }
        });

        // PDF text comes out in "drawing order" which can be scrambled (tables/columns).
        // Sorting by position (top->bottom, left->right) makes extraction much more stable.
        // Sort PDF.js text items into a more human-like reading order.
        // IMPORTANT: Use viewport-transformed coordinates (top-left origin), otherwise
        // PDF coordinate quirks can cause values to drift into the wrong building.
        function getSortedPageText(textContent, viewport) {
            const items = (textContent.items || [])
                .map(it => {
                    const t = it.transform || [1, 0, 0, 1, 0, 0];
                    // Transform to viewport/canvas coordinates (x right, y down)
                    const vt = pdfjsLib.Util.transform(viewport.transform, t);
                    return {
                        str: (it.str || '').trim(),
                        x: vt[4] || 0,
                        y: vt[5] || 0
                    };
                })
                .filter(it => it.str.length > 0);

            // Group nearby y's into the same line
            const yTol = 2.5;
            items.sort((a, b) => {
                const ay = Math.round(a.y / yTol) * yTol;
                const by = Math.round(b.y / yTol) * yTol;
                if (ay !== by) return ay - by; // top to bottom
                return a.x - b.x;              // left to right
            });

            let out = '';
            let lastLineY = null;
            for (const it of items) {
                const lineY = Math.round(it.y / yTol) * yTol;
                if (lastLineY !== null && lineY !== lastLineY) out += '\n';
                out += (out && !out.endsWith('\n') ? ' ' : '') + it.str;
                lastLineY = lineY;
            }

            return out
                .replace(/[ \t\f\r]+/g, ' ')
                .replace(/\n\s+/g, '\n')
                .trim();
        }

        async function extractPDFData(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            let allText = '';
            
            // Extract text from all pages
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1.0 });
                const textContent = await page.getTextContent();
                const pageText = getSortedPageText(textContent, viewport);
                allText += pageText + '\n';
            }

            // Extract sheet name (BBR address)
            let sheetName = 'Unknown';
            const addressMatch = allText.match(/BBR adresse:\s*([^(]+)/);
            if (addressMatch) {
                sheetName = addressMatch[1].trim();
            }

            // Parse building data
            const buildings = parseBuildings(allText);

            return { buildings, sheetName };
        }
        function parseBuildings(text) {
            const parseNumber = (s) => {
                if (s === undefined || s === null) return undefined;
                const cleaned = String(s)
                    .replace(/[^0-9,\.]/g, '')
                    .replace(/\./g, '')
                    .replace(/,/g, '.');
                const n = parseFloat(cleaned);
                return Number.isFinite(n) ? Math.round(n) : undefined;
            };

            // --- Strategy (v12) ---
            // 1) Find all Bygningsnr markers.
            // 2) For each building, try to extract from its nearby "Areal" subsection first.
            //    This prevents k√¶lder/tag values from drifting to the next building when the PDF text order is messy.
            // 3) Fallback to a midpoint block around the Bygningsnr marker.

            const bnRe = /Bygningsnr\.\s*:\s*(\d+)/ig;
            const bn = [];
            let m;
            while ((m = bnRe.exec(text)) !== null) {
                bn.push({ num: parseInt(m[1], 10), pos: m.index });
            }

            console.log('=== PARSE DEBUG (v12) ===');
            console.log('Bygningsnr found:', bn.map(x => x.num));

            if (!bn.length) return [];

            // Build symmetric midpoint blocks (avoid dumping the whole document header into building 1)
            const blocks = [];
            for (let i = 0; i < bn.length; i++) {
                const cur = bn[i];
                const prev = bn[i - 1];
                const next = bn[i + 1];

                let start;
                if (prev) {
                    start = Math.floor((prev.pos + cur.pos) / 2);
                } else if (next) {
                    start = Math.max(0, Math.floor(cur.pos - (next.pos - cur.pos) / 2));
                } else {
                    start = Math.max(0, cur.pos - 1500);
                }

                let end;
                if (next) {
                    end = Math.floor((cur.pos + next.pos) / 2);
                } else if (prev) {
                    end = Math.min(text.length, Math.floor(cur.pos + (cur.pos - prev.pos) / 2));
                } else {
                    end = text.length;
                }

                blocks.push({ num: cur.num, pos: cur.pos, section: text.substring(start, end), nextPos: next ? next.pos : null });
            }

            const getField = (section, label, mode = 'strict') => {
                // strict: number immediately after label (with optional ":" and unit)
                // relaxed: allow up to ~120 chars of non-digits between label and the first number
                let re;
                if (mode === 'relaxed') {
                    re = new RegExp(label + String.raw`[^0-9]{0,120}(\d+[\.,]?\d*)(?:\s*(?:m2|m¬≤))?`, 'i');
                } else {
                    re = new RegExp(label + String.raw`(?:\s*:\s*|\s+)(\d+[\.,]?\d*)(?:\s*(?:m2|m¬≤))?`, 'i');
                }
                const mm = section.match(re);
                return mm ? parseNumber(mm[1]) : undefined;
            };

            const getBygningsAreal = (section) => {
                // Handles: "Samlet bygningsareal (excl. k√¶lder 1096 ..." and similar.
                let mm = section.match(/Samlet bygningsareal[^0-9]{0,160}(\d+[\.,]?\d*)/i);
                if (mm) return parseNumber(mm[1]);
                return getField(section, 'Samlet bygningsareal', 'strict');
            };

            const getSamletAndetAreal = (section) => {
                // Prefer "row style" in Areal table if present
                const row = section.match(/Bebygget areal(?:\s*:\s*|\s+)\d+[\.,]?\d*(?:\s*(?:m2|m¬≤))?\s+Samlet andet areal(?:\s*:\s*|\s+)(\d+[\.,]?\d*)/i);
                if (row) return parseNumber(row[1]);

                const strict = section.match(/Samlet andet areal(?:\s*:\s*|\s+)(\d+[\.,]?\d*)/i);
                if (!strict) return undefined;

                const candidate = parseNumber(strict[1]);

                // Reject the common false-positive where we capture the unit "2" from "m 2" / header
                if (candidate === 2) {
                    const idx = strict.index ?? section.toLowerCase().indexOf(strict[0].toLowerCase());
                    const prev = section.slice(Math.max(0, idx - 12), idx).toLowerCase();
                    if (/\bm\s*$/.test(prev)) return undefined;
                }
                return candidate;
            };

            const findArealSubsection = (fromPos, toPos) => {
                // Look for the "Areal" header near the building marker.
                // Allow it to spill a bit after the next building marker (some PDFs reorder lines).
                const end = Math.min(text.length, (toPos ?? (fromPos + 6000)) + 2000);
                const window = text.substring(fromPos, end);
                const mA = window.match(/\bAreal\b/i);
                if (!mA) return null;

                const arealStart = fromPos + (mA.index ?? 0);

                // Stop at the next major header after Areal
                const after = text.substring(arealStart, end);
                const stop = after.match(/\b(Energipl|Kilde til bygningsareal|Kilde til bygningsarealer|Varmeinstallation|Materialer|Beliggenhed|Bygningsnr\.)\b/i);
                const arealEnd = stop ? (arealStart + (stop.index ?? after.length)) : end;

                return text.substring(arealStart, arealEnd);
            };

            const buildings = [];

            for (const b of blocks) {
                const section = b.section;
                const areal = findArealSubsection(b.pos, b.nextPos);

                const building = { 'Bygningsnr.': b.num };

                console.log(`\nBuilding ${b.num} (block length: ${section.length} chars):`);
                console.log(`First 260 chars: ${section.substring(0, 260)}`);
                if (areal) {
                    console.log(`Areal subsection length: ${areal.length}`);
                    console.log(`Areal first 220 chars: ${areal.substring(0, 220)}`);
                } else {
                    console.log('Areal subsection: NOT FOUND (will use midpoint block)');
                }

                const src = areal || section;

                // Core fields (prefer Areal subsection)
                building['Samlet bygningsareal'] = getBygningsAreal(src);
                building['Samlet k√¶lderareal'] = getField(src, 'Samlet k√¶lderareal', 'strict');
                building['Samlet tagetageareal'] = getField(src, 'Samlet tagetageareal', 'strict');
                building['Heraf udnyttet tagetage'] = getField(src, 'Heraf udnyttet tagetage', 'strict');

                // Samlet andet areal (prefer Areal subsection; fallback to full section)
                const andet = getSamletAndetAreal(src) ?? getSamletAndetAreal(section);
                if (andet !== undefined) building['Samlet andet areal'] = andet;

                // Bebygget areal (fallback)
                const beb = (src.match(/Bebygget areal(?:\s*:\s*|\s+)(\d+[\.,]?\d*)\s*(?:m2|m¬≤)?/i) ||
                             section.match(/Bebygget areal(?:\s*:\s*|\s+)(\d+[\.,]?\d*)\s*(?:m2|m¬≤)?/i));
                if (beb) building['Bebygget areal'] = parseNumber(beb[1]);

                // Clean undefined keys
                Object.keys(building).forEach(k => {
                    if (building[k] === undefined) delete building[k];
                });

                // Remove Bebygget if strong fields exist
                const hasStrongFields = ['Samlet bygningsareal', 'Samlet k√¶lderareal', 'Samlet tagetageareal', 'Heraf udnyttet tagetage', 'Samlet andet areal']
                    .some(k => building[k] !== undefined);

                if (hasStrongFields && building['Bebygget areal'] !== undefined) {
                    delete building['Bebygget areal'];
                }

                // Confidence & warnings
                let warnings = [];
                let confidence = 100;

                const hasAnyAreaField = hasStrongFields || (building['Bebygget areal'] !== undefined);

                if (!hasAnyAreaField) {
                    confidence = 50;
                    warnings.push('Ingen areal-felter fundet');
                } else if (!hasStrongFields && building['Bebygget areal'] !== undefined) {
                    confidence = 80;
                    warnings.push('Kun "Bebygget areal" fundet (fallback)');
                }

                if (!areal) {
                    confidence = Math.min(confidence, 90);
                    warnings.push('Areal-sektion ikke fundet (brugte blok)');
                }

                building['_Confidence'] = confidence;
                building['_Warnings'] = warnings.filter(Boolean).join('; ');

                buildings.push(building);
            }

            // Stable sort
            buildings.sort((a, b) => (a['Bygningsnr.'] || 0) - (b['Bygningsnr.'] || 0));

            console.log('\n=== FINAL RESULT ===');
            console.log('Buildings:', JSON.stringify(buildings, null, 2));

            return buildings;
        }


        function showStatus(type, message) {
            status.className = 'status ' + type;
            status.textContent = message;
        }

        function showProgress(show) {
            progress.style.display = show ? 'block' : 'none';
            if (!show) {
                progressFill.style.width = '0%';
            }
        }

        function updateProgress(percent, text) {
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
        }

        // Preview Modal Functions
        function showPreview() {
            if (!processedData) return;

            const modal = document.getElementById('previewModal');
            const tabsContainer = document.getElementById('sheetTabs');
            const contentsContainer = document.getElementById('sheetContents');

            // Clear previous content
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';

            // Create tabs and content for each sheet
            processedData.allData.forEach((sheet, index) => {
                // Create tab
                const tab = document.createElement('button');
                tab.className = 'sheet-tab' + (index === 0 ? ' active' : '');
                tab.textContent = sheet.sheetName;
                tab.onclick = () => switchTab(index);
                tabsContainer.appendChild(tab);

                // Create content
                const content = document.createElement('div');
                content.className = 'sheet-content' + (index === 0 ? ' active' : '');
                content.id = 'sheet-' + index;
                content.innerHTML = generateTableHTML(sheet.data, processedData.selectedColumns);
                contentsContainer.appendChild(content);
            });

            // Add Grand Total tab
            const grandTab = document.createElement('button');
            grandTab.className = 'sheet-tab';
            grandTab.textContent = 'Grand Total';
            grandTab.onclick = () => switchTab(processedData.allData.length);
            tabsContainer.appendChild(grandTab);

            const grandContent = document.createElement('div');
            grandContent.className = 'sheet-content';
            grandContent.id = 'sheet-' + processedData.allData.length;
            grandContent.innerHTML = generateTableHTML(processedData.grandTotals, processedData.selectedColumns);
            contentsContainer.appendChild(grandContent);

            modal.classList.add('show');
        }

        function closePreview() {
            const modal = document.getElementById('previewModal');
            modal.classList.remove('show');
        }

        function switchTab(index) {
            // Update tab styles
            document.querySelectorAll('.sheet-tab').forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Update content visibility
            document.querySelectorAll('.sheet-content').forEach((content, i) => {
                if (i === index) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
        }

        function generateTableHTML(data, columns) {
            if (!data || data.length === 0) {
                return '<p>Ingen data</p>';
            }

            let html = '<table class="preview-table"><thead><tr>';
            
            // Add headers (columns + Total)
            columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '<th>Total (row sum)</th>';
            html += '</tr></thead><tbody>';

            // Add rows
            data.forEach((row, index) => {
                const isTotal = index === data.length - 1 || typeof row['Bygningsnr.'] === 'string';
                html += `<tr class="${isTotal ? 'total-row' : ''}">`;
                
                // Add column values
                columns.forEach(col => {
                    let value = row[col];
                    // Show empty cells as "-" only for non-total rows
                    // For total rows, show actual 0 or the value
                    if (value === undefined || value === null || value === '') {
                        if (isTotal) {
                            value = col.startsWith('_') ? '' : 0;
                        } else {
                            value = '-';
                        }
                    }
                    html += `<td>${value}</td>`;
                });
                
                // Calculate and add row total (sum of all numeric columns in this row)
                let rowSum = 0;
                columns.forEach(col => {
                    if (col !== 'Bygningsnr.' && !col.startsWith('_')) {
                        const val = parseInt(row[col]) || 0;
                        rowSum += val;
                    }
                });
                
                html += `<td><strong>${rowSum}</strong></td>`;
                
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        function downloadExcel() {
            if (!processedData) return;

            // Generate Excel file
            const wb = XLSX.utils.book_new();

            // Add individual sheets
            processedData.allData.forEach(sheet => {
                const ws = XLSX.utils.json_to_sheet(sheet.data);
                XLSX.utils.book_append_sheet(wb, ws, sheet.sheetName.substring(0, 31));
            });

            // Add grand total sheet
            const grandTotalWs = XLSX.utils.json_to_sheet(processedData.grandTotals);
            XLSX.utils.book_append_sheet(wb, grandTotalWs, 'Grand Total');

            // Download file
            XLSX.writeFile(wb, 'bbr_data.xlsx');

            showStatus('success', '‚úì Excel fil downloadet!');
            closePreview();
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('previewModal');
            if (event.target === modal) {
                closePreview();
            }
        }
    </script>
</body>
</html>
