<!DOCTYPE html>

<html lang="da">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>BBR PDF Data Ekstraktor</title>
<style>
:root{
  --bg:#f6f7fb;
  --card:#ffffff;
  --text:#111827;
  --muted:#6b7280;
  --border:#e5e7eb;
  --primary:#2563eb;
  --primary2:#1d4ed8;
  --ok:#16a34a;
  --warn:#f59e0b;
  --err:#dc2626;
  --shadow:0 10px 25px rgba(0,0,0,.08);
  --radius:18px;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
  /* Behold den oprindelige baggrundsfarve (fra den gamle version) */
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color:var(--text);
}
.container{
  max-width:980px;
  margin:18px auto 40px;
  padding:0 14px;
}

.header{
  text-align:center;
  color:#fff;
  margin: 10px 0 18px;
}
.header h1{
  font-size: 2.2rem;
  margin: 0 0 6px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.18);
}
.header p{
  margin:0;
  font-size: 1.05rem;
  opacity: .92;
}
.header .meta{
  margin-top:10px;
  font-size: .95rem;
  opacity: .88;
}
.header .meta span{font-weight:800}

.topbar{
  /* Match den gamle farveprofil */
  background:linear-gradient(135deg,#667eea 0%, #764ba2 100%);
  color:#fff;
  border-radius:22px;
  padding:18px 18px;
  box-shadow:var(--shadow);
}
.topbar-row{
  display:flex;
  gap:14px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}
.topbar h1{
  margin:0;
  font-size:22px;
  line-height:1.2;
}
.topbar .sub{
  margin-top:6px;
  color:rgba(255,255,255,.88);
  font-size:13px;
}
.badges{
  display:flex;
  flex-direction:column;
  gap:8px;
  align-items:flex-end;
}
.badge{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.16);
  border:1px solid rgba(255,255,255,.22);
  font-size:13px;
  white-space:nowrap;
}
.badge strong{font-weight:800}
.cards{
  display:flex;
  flex-direction:column;
  gap:14px;
  margin-top:14px;
}
.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:16px;
}
.card h2{
  margin:0;
  /* Headings: slightly larger, but not bold */
  font-size:18px;
  font-weight:500;
  letter-spacing:0.1px;
}
.card .hint{
  margin-top:6px;
  color:var(--muted);
  font-size:13px;
}
.row{
  display:flex;
  gap:10px;
  align-items:stretch;
  flex-wrap:wrap;
  margin-top:12px;
}
.input{
  flex:1 1 320px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.label{font-size:13px;color:var(--muted)}
input[type="text"]{
  width:100%;
  padding:12px 12px;
  border:1px solid var(--border);
  border-radius:14px;
  font-size:14px;
  outline:none;
}
textarea{
  width:100%;
  padding:12px 12px;
  border:1px solid var(--border);
  border-radius:14px;
  font-size:14px;
  resize:vertical;
  min-height:90px;
}

input[type="text"]:focus{border-color:rgba(37,99,235,.55); box-shadow:0 0 0 4px rgba(37,99,235,.12)}

/* OIS link line: input + buttons on same baseline */
.ois-inline{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.ois-inline input[type="text"]{
  flex:1 1 420px;
  min-width:260px;
}
.ois-inline .btn{
  white-space:nowrap;
}
.btn{
  background:#fff;
  color:#111827;
  border:1px solid var(--border);
  padding:12px 14px;
  border-radius:14px;
  font-weight:400; /* ikke fed ‚Äì som den oprindelige */
  cursor:pointer;
  font-size:14px;
  transition:background .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease;
}

/* "Prim√¶r" knap: hvid som standard, farves ved hover */
.btn-primary{
  background:#fff;
  color:var(--primary);
  border:1px solid rgba(37,99,235,.45);
}
.btn-primary:hover{
  background:var(--primary);
  color:#fff;
  border-color:var(--primary);
  box-shadow:0 8px 22px rgba(37,99,235,.22);
}

/* Sekund√¶r knap: hvid/gr√• hover */
.btn-secondary{
  background:#fff;
  color:#111827;
  border:1px solid var(--border);
}
.btn-secondary:hover{background:#f3f4f6}
.btn:disabled{opacity:.55; cursor:not-allowed}

.uploader{
  margin-top:12px;
}
.uploader-head{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}
.upload-area{
  border:3px dashed #d0d0d0;
  border-radius:12px;
  padding:30px 18px; /* lidt lavere end original */
  text-align:center;
  cursor:pointer;
  transition:all .3s;
  background:#fafafa;
  margin-top:10px;
}
.upload-area:hover{
  border-color:#667eea;
  background:#f8f9ff;
}
.upload-area.dragover{
  border-color:#667eea;
  background:#f0f4ff;
  transform:scale(1.01);
}
.upload-icon{font-size:3.2rem; margin-bottom:10px}
.upload-text{font-size:1.05rem; color:#555; margin-bottom:6px}
.upload-subtext{color:#888; font-size:.95rem}

.file-list{
  margin-top:10px;
  font-size:13px;
  color:var(--muted);
}
.process-row{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
  margin-top:12px;
}
.process-btn{
  background:#fff;
  color:var(--primary);
  border:1px solid rgba(37,99,235,.45);
  padding:12px 14px;
  border-radius:14px;
  font-weight:400;
  cursor:pointer;
  transition:background .18s ease, color .18s ease, border-color .18s ease, box-shadow .18s ease;
}
.process-btn:hover{
  background:var(--primary);
  color:#fff;
  border-color:var(--primary);
  box-shadow:0 8px 22px rgba(37,99,235,.22);
}
.process-btn:disabled{opacity:.5; cursor:not-allowed}

.progress{margin-top:10px; display:none}
.progress-bar{height:10px; background:#eef2ff; border-radius:999px; overflow:hidden}
.progress-fill{height:100%; width:0%; background:var(--primary)}
.progress-text{margin-top:8px; font-size:13px; color:var(--muted)}

.section-grid{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  margin-top:12px;
}
@media (min-width: 860px){
  .section-grid{grid-template-columns:1fr 1fr}
}
.group{
  border:1px solid var(--border);
  border-radius:16px;
  padding:12px;
  background:#fff;
}
.group h3{margin:0; font-size:14px}
.group .subhint{margin-top:6px; font-size:12px; color:var(--muted)}
.checks{
  margin-top:10px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.check{
  display:flex;
  gap:10px;
  align-items:flex-start;
  padding:8px 10px;
  border-radius:14px;
  border:1px solid #f3f4f6;
  background:#fafafa;
}
.check input{margin-top:3px}
.check label{font-size:14px}
.mini-actions{
  margin-top:10px;
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.mini-link{
  background:transparent;
  border:0;
  color:var(--primary);
  font-weight:800;
  cursor:pointer;
  padding:0;
}
.mini-link:hover{text-decoration:underline}

.details{
  margin-top:12px;
  border:1px solid var(--border);
  border-radius:16px;
  overflow:hidden;
}
details summary{
  list-style:none;
  cursor:pointer;
  padding:12px 12px;
  background:#fff;
  font-weight:900;
  display:flex;
  align-items:center;
  justify-content:space-between;
}
details summary::-webkit-details-marker{display:none}
.details-body{
  padding:12px;
  background:#fafafa;
  border-top:1px solid var(--border);
  color:var(--muted);
  font-size:13px;
}

.result-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  flex-wrap:wrap;
}
.actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.actions .btn{padding:10px 12px}

.modal{display:none; position:fixed; inset:0; background:rgba(17,24,39,.55); padding:16px; z-index:999}
.modal.show{display:block}
.modal-content{
  background:#fff;
  border-radius:20px;
  max-width:980px;
  margin:0 auto;
  height:calc(100vh - 32px);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}
.modal-header{
  padding:14px 16px;
  border-bottom:1px solid var(--border);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.modal-header h2{margin:0; font-size:16px}
.modal-close{
  font-size:24px;
  cursor:pointer;
  color:var(--muted);
}
.modal-body{
  padding:14px 16px;
  overflow:auto;
  flex:1;
}
.sheet-tabs{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-bottom:10px;
}
.sheet-tab{
  border:1px solid var(--border);
  background:#fff;
  border-radius:999px;
  padding:8px 10px;
  cursor:pointer;
  font-weight:800;
  font-size:13px;
}
.sheet-tab.active{background:#eef2ff; border-color:#c7d2fe}
.modal-footer{
  padding:12px 16px;
  border-top:1px solid var(--border);
  display:flex;
  gap:10px;
  justify-content:flex-end;
  flex-wrap:wrap;
}
.modal-btn{
  border:0;
  padding:10px 12px;
  border-radius:14px;
  font-weight:900;
  cursor:pointer;
}
.modal-btn-cancel{background:#f3f4f6}
.modal-btn-primary{background:var(--primary); color:#fff}

.table-wrap{overflow:auto; border:1px solid var(--border); border-radius:14px; background:#fff}

.meta-table-wrap{margin:12px 0}
.meta-table{width:100%; border-collapse:collapse; font-size:13px}
.meta-table th{background:#fafafa; border-bottom:1px solid #f3f4f6; padding:10px; text-align:left}
.meta-table td{border-bottom:1px solid #f3f4f6; padding:10px; white-space:normal}

table{border-collapse:collapse; width:100%; font-size:13px}
th,td{border-bottom:1px solid #f3f4f6; padding:10px 10px; text-align:left; white-space:nowrap}
th{background:#fafafa; position:sticky; top:0; z-index:1}
.status{
  margin-top:12px;
  padding:10px 12px;
  border-radius:16px;
  border:1px solid var(--border);
  background:#fff;
  color:var(--muted);
  font-size:13px;
  display:none;
}

.columns-grid{display:flex;flex-direction:column;gap:8px;margin-top:10px}
.column-checkbox{
  display:flex; gap:10px; align-items:flex-start;
  padding:8px 10px; border-radius:14px;
  border:1px solid #f3f4f6; background:#fafafa;
  cursor:pointer;
}
.column-checkbox input{margin-top:3px}
.column-checkbox label{font-size:14px; cursor:pointer}
.section-title{margin:0}

.status.info{display:block;color:#374151;background:#fff}
.status.success{display:block;border-color:rgba(22,163,74,.25);background:rgba(22,163,74,.08);color:#166534}
.status.warning{display:block;border-color:rgba(245,158,11,.25);background:rgba(245,158,11,.10);color:#92400e}
.status.error{display:block;border-color:rgba(220,38,38,.25);background:rgba(220,38,38,.10);color:#991b1b}


.uploader-title{font-weight:600; font-size:1.05rem;}
/* Dropdown (details) should not look overly bold */
.details summary{
  font-weight:600;
}
.details summary::-webkit-details-marker{display:none;}
.details summary{
  list-style:none;
}
.details-muted{
  color:var(--muted);
  font-weight:400;
  margin-left:6px;
}


/* Preview tab content visibility */
.preview-tabs { display:flex; gap:10px; flex-wrap:wrap; margin: 12px 0 14px; }
.preview-tabs button, .sheet-tab { border:1px solid #d4d9ff; background:#fff; padding:8px 14px; border-radius:999px; cursor:pointer; font-weight:400; }
.preview-tabs button, .sheet-tab.active { background:#eef1ff; }
.sheet-content { display:none; }
.sheet-content.active { display:block; }
/* Make preview table area nicer */
.preview-content { max-height: 65vh; overflow:auto; border-top:1px solid #eee; padding-top: 6px; }
.preview-content table { width:100%; border-collapse:collapse; }
.preview-content th { position: sticky; top: 0; background:#fafafa; z-index:1; }
.preview-content th, .preview-content td { padding:10px 12px; border-bottom:1px solid #eee; font-size: 13px; }
.preview-content tr:nth-child(even) td { background:#fcfcff; }

.failbox{
  margin-top:12px;
  padding:12px 12px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.25);
  background:rgba(255,255,255,.14);
  color:#fff;
}
.failbox h3{
  margin:0 0 8px;
  font-size:14px;
  letter-spacing:.2px;
}
.failbox .small{
  font-size:12px;
  opacity:.9;
  margin-bottom:8px;
}
.failbox ul{
  margin:0;
  padding-left:18px;
}
.failbox li{
  margin:4px 0;
  font-size:13px;
  word-break:break-word;
}
.failbox code{
  background:rgba(0,0,0,.25);
  padding:2px 6px;
  border-radius:999px;
  color:#fff;
}
.failbox .actions{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
}

</style>

  <!-- Libraries (kept from the original working version) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // pdf.js worker (must be set after pdfjsLib is available)
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

</head>
<body>

<div class="container">
  <div class="header">
    <h1>üìÑ BBR Udtr√¶k</h1>
    <p>Inds√¶t OIS-link eller upload en BBR PDF. V√¶lg kolonner og download til Excel.</p>
    <div class="meta">Adresse: <span id="addressBadge">Ukendt</span> &nbsp;‚Ä¢&nbsp; Status: <span id="statusBadge">Klar</span></div>
  </div>

  <div class="cards">

    <!-- Step 1 -->
    <div class="card" id="step1">
      <h2>1) Hent PDF fra OIS</h2>
      <div class="hint">Inds√¶t et OIS-link (fx <code>/search/10171611/...</code>). Alternativt kan du uploade en PDF manuelt.</div>

      <div class="input">
        <div class="label">OIS-link</div>
        <div class="ois-inline">
          <input id="oisLinkInput" type="text" placeholder="Inds√¶t OIS-link her‚Ä¶" />
          <button id="oisFetchExtractBtn" type="button" class="btn btn-primary">Indl√¶s</button>
          <button id="oisOpenPdfBtn" type="button" class="btn btn-secondary">√Öbn PDF i ny fane</button>
        </div>
        <div id="oisHint" class="hint" style="margin-top:6px;"></div>
      </div>


      <div class="input" style="margin-top:14px;">
        <div class="label">Batch BFE-numre</div>
        <textarea id="bfeBatchInput" placeholder="Inds√¶t BFE-numre (√©t pr. linje eller adskilt af komma/space)‚Ä¶"></textarea>
        <div class="ois-inline" style="margin-top:8px; gap:8px;">
          <button id="bfeBatchFetchBtn" type="button" class="btn btn-primary">Hent alle via proxy</button>
          <button id="bfeBatchLinksBtn" type="button" class="btn btn-secondary">Kopi√©r OIS-links</button>
          <button id="bfeBatchOpenBtn" type="button" class="btn btn-secondary">√Öbn n√¶ste OIS-side</button>
        </div>
        <div id="bfeBatchHint" class="hint" style="margin-top:6px;"></div>
      </div>


      <div id="bfeFailBox" class="failbox" style="display:none;">
        <h3>Fejl ved hentning af BFE</h3>
        <div class="small">Disse BFE-numre kunne ikke hentes (fx ustabilt netv√¶rk). Du kan kopiere eller hente dem igen.</div>
        <div id="bfeFailSummary" class="small"></div>
        <ul id="bfeFailList"></ul>
        <div class="actions">
          <button id="bfeFailCopyBtn" type="button" class="btn btn-secondary">Kopi√©r fejlede BFE</button>
          <button id="bfeFailRetryBtn" type="button" class="btn btn-primary">Hent fejlede igen</button>
          <button id="bfeFailClearBtn" type="button" class="btn btn-secondary">Ryd liste</button>
        </div>
      </div>



      <div class="uploader">
        <div class="uploader-head">
          <div>
            <div class="uploader-title">Alternativ: Upload PDF</div>
            <div class="hint">Hvis automatisk hentning fejler, s√• upload PDF‚Äôen her.</div>
          </div>
          <!-- Fjernet "V√¶lg PDF-fil" knap: upload-boksen kan klikkes -->
          <input id="fileInput" type="file" multiple style="display:none" />
        </div>

        <div id="uploadArea" class="upload-area" role="button" tabindex="0" aria-label="Upload PDF">
          <div class="upload-icon">üìÅ</div>
          <div class="upload-text">Tr√¶k og slip PDF-filer her</div>
          <div class="upload-subtext">eller klik for at v√¶lge filer</div>
        </div>

        <div class="file-list" id="fileList"></div>
<div class="progress" id="progress">
          <div class="progress-text" style="margin-bottom:6px; font-weight:600; color:var(--muted);">Hentning</div>
          <div class="progress-bar"><div class="progress-fill" id="progressFillFetch"></div></div>
          <div class="progress-text" id="progressTextFetch"></div>

          <div style="height:10px"></div>

          <div class="progress-text" style="margin-bottom:6px; font-weight:600; color:var(--muted);">Indl√¶sning</div>
          <div class="progress-bar"><div class="progress-fill" id="progressFillParse"></div></div>
          <div class="progress-text" id="progressTextParse"></div>
        </div>

        <div class="status" id="status"></div>
      </div>
    </div>

    <!-- Step 2 -->
    <div class="card" id="step2">
      <h2>2) V√¶lg hvad der skal med</h2>
      <div class="hint">Arealer kan summeres. ‚ÄúAnden data‚Äù bliver ikke summeret og skjules p√• Samlet.</div>

      <div class="section-grid">
        <div class="group">
          <h3>Arealer</h3>
          <div class="subhint">Typisk det vigtigste. Summeres i totaler.</div>
          <div class="checks" id="columnsGrid">
            <div class="column-checkbox" onclick="toggleCheckbox('col1')">
<input checked="" id="col1" type="checkbox" value="Samlet bygningsareal"/>
<label for="col1">Samlet bygningsareal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col2')">
<input checked="" id="col2" type="checkbox" value="Samlet k√¶lderareal"/>
<label for="col2">Samlet k√¶lderareal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col3')">
<input checked="" id="col3" type="checkbox" value="Samlet tagetageareal"/>
<label for="col3">Samlet tagetageareal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col4')">
<input id="col4" type="checkbox" value="Heraf udnyttet tagetage"/>
<label for="col4">Heraf udnyttet tagetage</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col5')">
<input checked="" id="col5" type="checkbox" value="Samlet andet areal"/>
<label for="col5">Samlet andet areal</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col6')">
<input checked="" id="col6" type="checkbox" value="Bebygget areal"/>
<label for="col6">Bebygget areal (bruges kun hvis andre ikke er udfyldt)</label>
</div>
          </div>
        </div>

        <div class="group">
          <h3>Anden data</h3>
          <div class="subhint">Vises pr. bygning, men bliver ikke summeret.</div>
          <div class="checks" id="otherColumnsGrid">
            <div class="column-checkbox" onclick="toggleCheckbox('col7')">
<input id="col7" type="checkbox" value="Opf√∏relses√•r"/>
<label for="col7">Opf√∏relses√•r</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col8')">
<input id="col8" type="checkbox" value="Antal etager u. k√¶lder &amp; tagetage"/>
<label for="col8">Antal etager u. k√¶lder &amp; tagetage</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col9')">
<input id="col9" type="checkbox" value="Yderv√¶ggens materiale"/>
<label for="col9">Yderv√¶ggens materiale</label>
</div>
<div class="column-checkbox" onclick="toggleCheckbox('col10')">
<input id="col10" type="checkbox" value="Tagd√¶kningsmateriale"/>
<label for="col10">Tagd√¶kningsmateriale</label>
</div>

<div class="column-checkbox" onclick="toggleCheckbox('col11')">
<input id="col11" type="checkbox" value="Bygningens anvendelse"/>
<label for="col11">Bygningens anvendelse</label>
</div>

<div class="column-checkbox" onclick="toggleCheckbox('col12')">
<input id="col12" type="checkbox" value="Erhvervsareal"/>
<label for="col12">Erhvervsareal</label>
</div>
          </div>
        </div>
      </div>

      <div class="details">
        <details>
          <summary>Fejl &amp; kvalitet <span class="details-muted">(fold ud)</span></summary>
          <div class="details-body">
            <div style="margin-bottom:10px;">Brug kun hvis noget ser forkert ud.</div>
            <div class="checks" style="gap:10px;">
              <div class="check">
                <input id="qWarn" type="checkbox" />
                <div>
                  <label for="qWarn"><strong>Advarsler</strong></label>
                  <div class="subhint">Tilf√∏j en kolonne med korte advarsler pr. bygning.</div>
                </div>
              </div>
              <div class="check">
                <input id="qConf" type="checkbox" />
                <div>
                  <label for="qConf"><strong>P√•lidelighed (0‚Äì100)</strong></label>
                  <div class="subhint">Giver en hurtig indikation af hvor ‚Äúsikker‚Äù udtr√¶kningen er.</div>
                </div>
              </div>
              <div class="check">
                <input id="debugConsole" type="checkbox" />
                <div>
                  <label for="debugConsole"><strong>Debug i konsollen</strong></label>
                  <div class="subhint">Viser ekstra detaljer (kr√¶ver F12).</div>
                </div>
              </div>
            </div>
          </div>
        </details>
      </div>
    </div>

    <!-- Step 3 -->
    <div class="card" id="step3">
      <div class="result-head">
        <div>
          <h2>3) Resultat</h2>
          <div class="hint">Brug ‚ÄúPreview data‚Äù for at se tabs og download Excel.</div>
        </div>
        <div class="actions">
          <button type="button" class="process-btn" id="processBtn" disabled>Preview data</button>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- Preview Modal -->
<div class="modal" id="previewModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Preview</h2>
      <span class="modal-close" onclick="closePreview()">√ó</span>
    </div>
    <div class="modal-body">
      <div class="sheet-tabs" id="sheetTabs"></div>
      <div id="sheetContents"></div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-secondary" onclick="closePreview()">Luk</button>
      <button class="btn btn-primary" onclick="downloadExcel()">Download Excel</button>
    </div>
  </div>
</div>


<script>

        // Initialize PDF.js (guarded: many corporate networks block CDNs)
        // If pdfjsLib isn't available, we still want the UI/uploader to work and show a clear error on processing.
        if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        } else {
            console.warn('pdfjsLib not loaded. If you are on a corporate network, CDNs may be blocked.');
        }

        // State management
        let selectedFiles = [];
        let processedData = null; // Store processed data for preview and download
        let pipelineActive = false;
        let pipelineSelectedColumns = null;
        let pipelineAllData = null;
        let pipelineGrandTotals = null;
        let pipelineTotalCount = 0;
        let pipelineCompleted = 0;
        let pipelineFinalized = false;

        function startPipeline(selectedColumns, totalCount) {
            pipelineActive = true;
            pipelineFinalized = false;
            pipelineSelectedColumns = selectedColumns;
            pipelineAllData = [];
            pipelineGrandTotals = [];
            pipelineTotalCount = totalCount;
            pipelineCompleted = 0;
        }

        async function pipelineConsumeFile(file) {
            if (!pipelineActive || !pipelineSelectedColumns) return;
            await processSingleFile(
                file,
                pipelineSelectedColumns,
                pipelineAllData,
                pipelineGrandTotals,
                pipelineCompleted,
                pipelineTotalCount
            );
            pipelineCompleted += 1;
        }

        function finalizePipeline() {
            if (!pipelineActive || pipelineFinalized) return null;
            pipelineFinalized = true;

            const selectedColumns = pipelineSelectedColumns;
            const allData = pipelineAllData;
            const grandTotals = pipelineGrandTotals;

            // Create grand total sheet
            const finalTotalRow = {};
            finalTotalRow['Bygningsnr.'] = 'Final Total';
            finalTotalRow['Ejendomsnummer (BFE-nr.)'] = '-';

            selectedColumns.forEach(col => {
                if (col === 'Bygningsnr.') return;

                if (typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(col)) {
                    const sum = grandTotals.reduce((acc, row) => acc + (parseInt(row[col], 10) || 0), 0);
                    finalTotalRow[col] = sum;
                    return;
                }

                if (col === '_Confidence') {
                    const vals = grandTotals
                        .map(r => (typeof r[col] === 'number' ? r[col] : parseInt(r[col], 10)))
                        .filter(v => typeof v === 'number' && !isNaN(v));
                    finalTotalRow[col] = vals.length ? Math.round(vals.reduce((a, x) => a + x, 0) / vals.length) : '-';
                    return;
                }

                if (col === '_Warnings') { finalTotalRow[col] = '-'; return; }

                finalTotalRow[col] = '-';
            });

            const finalRowTotal = Object.keys(finalTotalRow)
                .filter(k => k !== 'Bygningsnr.' && k !== 'Total')
                .reduce((acc, k) => acc + ((typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(k)) ? (parseInt(finalTotalRow[k], 10) || 0) : 0), 0);
            finalTotalRow['Total'] = finalRowTotal;

            grandTotals.push(finalTotalRow);

            processedData = {
                allData,
                grandTotals,
                selectedColumns
            };

            return processedData;
        }


        // --- Text normalization (handles new PDF layout where letters/numbers are split with spaces) ---
        function normalizeText(raw) {
            if (!raw) return '';
            let t = raw;

            // Fix common unit split: "m 2" -> "m2"
            t = t.replace(/m\s+2/g, 'm2');

            // Merge spaced digits: "1 0 9 6" -> "1096"
            t = t.replace(/\b(?:\d\s+){1,}\d\b/g, (m) => m.replace(/\s+/g, ''));

            // Merge spaced letters for Danish alphabet (words split into single letters)
            // Example: "B y g n i n g e n s" -> "Bygningens"
            t = t.replace(/\b(?:[A-Za-z√Ü√ò√Ö√¶√∏√•]\s+){2,}[A-Za-z√Ü√ò√Ö√¶√∏√•]\b/g, (m) => m.replace(/\s+/g, ''));

            // Collapse multiple spaces/newlines
            t = t.replace(/\s+/g, ' ').trim();
            return t;
        }

        function looksLikeStreetAddress(candidate) {
            const s = String(candidate || '').trim();
            if (!s) return false;

            // Must look like "Street name + house number"
            if (!/[A-Za-z√Ü√ò√Ö√¶√∏√•]{2,}\s+\d/.test(s)) return false;
            if (!/\b\d{1,4}[A-Za-z]?\b/.test(s)) return false;
            if (s.length < 4) return false;

            const low = s.toLowerCase();

            // Reject obvious authority/header text (common in municipal PDFs)
            const badTokens = [
                'kommune', 'myndighed', 'forvaltning', 'center', 'afdeling',
                'bygge', 'milj√∏', 'parkering', 'p-',
                'cvr', 'telefon', 'tlf', 'email', 'e-mail', 'www', 'postboks'
            ];
            if (badTokens.some(t => low.includes(t))) return false;

            // Reject if it looks like a long sentence rather than an address
            if (s.split(' ').length > 8) return false;

            return true;
        }





        // Extract Ejendomsnummer (BFE-nr.) (property-level)
        function extractBFE(text) {
            if (!text) return undefined;
            // Try with spaces
            let m = text.match(/Ejendomsnummer\s*\(\s*BFE-?nr\.?\s*\)\s*:\s*(\d{6,})/i);
            if (m && m[1]) return m[1];

            // Try no-space variant (new layout can concatenate words)
            const ns = text.replace(/\s+/g, '');
            m = ns.match(/Ejendomsnummer\(BFE-?nr\.?\):(\d{6,})/i);
            if (m && m[1]) return m[1];

            return undefined;
        }

        // Extract Kommunenummer (first 3 digits from "kommunalt ejendomsnummer: 820-8593")
        function extractKommunenummer(text) {
            if (!text) return undefined;
            // With spaces
            let m = text.match(/kommunalt\s+ejendomsnummer\s*:\s*(\d{3})\s*-\s*\d+/i);
            if (m && m[1]) return m[1];
            // No-space variant
            const ns = text.replace(/\s+/g, '');
            m = ns.match(/kommunaltejendomsnummer:(\d{3})-\d+/i);
            if (m && m[1]) return m[1];
            return undefined;
        }

        // Extract Matrikelnummer (token before comma)
        function extractMatrikelnummer(text) {
            if (!text) return undefined;
            let m = text.match(/Matrikelnummer\s*:\s*([^,\s]+)\s*,/i);
            if (m && m[1]) return m[1].trim();
            const ns = text.replace(/\s+/g, '');
            m = ns.match(/Matrikelnummer:([^,]+),/i);
            if (m && m[1]) return m[1].trim();
            return undefined;
        }

        // Column mapping - always include Bygningsnr. first
        const allColumns = [
            'Bygningsnr.',
            'Samlet bygningsareal',
            'Samlet k√¶lderareal',
            'Samlet tagetageareal',
            'Heraf udnyttet tagetage',
            'Samlet andet areal',
            'Bebygget areal'
        ];

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const debugConsoleEl = document.getElementById('debugConsole');
        if (debugConsoleEl) debugConsoleEl.checked = false; // default: debug off

        const processBtn = document.getElementById('processBtn');
        const oisLinkInput = document.getElementById('oisLinkInput');
        const oisOpenPdfBtn = document.getElementById('oisOpenPdfBtn');
        const oisFetchExtractBtn = document.getElementById('oisFetchExtractBtn');
       const PROXY_BASE = 'https://ois-bbr-proxy.thelighty9.workers.dev';
        const getProxyBase = () => PROXY_BASE;

        const oisHint = document.getElementById('oisHint');

        const bfeBatchInput = document.getElementById('bfeBatchInput');
        const bfeBatchFetchBtn = document.getElementById('bfeBatchFetchBtn');
        const bfeBatchLinksBtn = document.getElementById('bfeBatchLinksBtn');
        const bfeBatchOpenBtn = document.getElementById('bfeBatchOpenBtn');
        const bfeBatchHint = document.getElementById('bfeBatchHint');
        const bfeFailBox = document.getElementById('bfeFailBox');
        const bfeFailList = document.getElementById('bfeFailList');
        const bfeFailSummary = document.getElementById('bfeFailSummary');
        const bfeFailCopyBtn = document.getElementById('bfeFailCopyBtn');
        const bfeFailRetryBtn = document.getElementById('bfeFailRetryBtn');
        const bfeFailClearBtn = document.getElementById('bfeFailClearBtn');

        // Track BFE fetch failures (to help with unstable connections)
        let fetchFailures = []; // { bfe: "123", message: "..." }
        // Session cache for PDFs (BFE -> ArrayBuffer). Speeds up retries and re-runs.
        const pdfCache = new Map(); // bfe -> ArrayBuffer
        const pdfCacheOrder = [];   // FIFO for eviction
        const PDF_CACHE_MAX = 200;  // adjust if needed

        function cachePut(bfe, buf) {
            const key = String(bfe);
            if (!key || !buf) return;
            if (pdfCache.has(key)) return;
            pdfCache.set(key, buf);
            pdfCacheOrder.push(key);
            while (pdfCacheOrder.length > PDF_CACHE_MAX) {
                const old = pdfCacheOrder.shift();
                if (old) pdfCache.delete(old);
            }
        }

        function cacheGet(bfe) {
            const key = String(bfe);
            return pdfCache.get(key);
        }


        function addFetchFailure(bfe, message) {
            if (!bfe) return;
            const sBfe = String(bfe);
            const msg = message ? String(message) : 'Ukendt fejl';
            const existing = fetchFailures.find(x => x.bfe === sBfe);
            if (existing) existing.message = msg;
            else fetchFailures.push({ bfe: sBfe, message: msg });
            renderFetchFailures();
        }

        function clearFetchFailure(bfe) {
            const sBfe = String(bfe);
            fetchFailures = fetchFailures.filter(x => x.bfe !== sBfe);
            renderFetchFailures();
        }

        function clearAllFetchFailures() {
            fetchFailures = [];
            renderFetchFailures();
        }

        function renderFetchFailures() {
            if (!bfeFailBox || !bfeFailList) return;
            if (!fetchFailures.length) {
                bfeFailBox.style.display = 'none';
                bfeFailList.innerHTML = '';
                if (bfeFailSummary) bfeFailSummary.textContent = '';
                return;
            }
            bfeFailBox.style.display = 'block';
            if (bfeFailSummary) bfeFailSummary.textContent = `Fejl: ${fetchFailures.length}`;
            bfeFailList.innerHTML = fetchFailures
              .map(x => `<li><code>${escapeHtml(x.bfe)}</code> ‚Äì ${escapeHtml(x.message)}</li>`)
              .join('');
        }


        const status = document.getElementById('status');
        const progress = document.getElementById('progress');

        const progressFillFetch = document.getElementById('progressFillFetch');
        const progressTextFetch = document.getElementById('progressTextFetch');
        const progressFillParse = document.getElementById('progressFillParse');
        const progressTextParse = document.getElementById('progressTextParse');

        // Checkbox management
        function toggleCheckbox(id) {
            const ev = window.event;
            if (ev && ev.stopPropagation) ev.stopPropagation();
            const checkbox = document.getElementById(id);
            checkbox.checked = !checkbox.checked;
            updateCheckboxStyles();
            updateProcessButton();
        }

        function updateCheckboxStyles() {
            document.querySelectorAll('.column-checkbox').forEach(div => {
                const checkbox = div.querySelector('input[type="checkbox"]');
                if (checkbox.checked) {
                    div.classList.add('checked');
                } else {
                    div.classList.remove('checked');
                }
            });
        }

        function selectAll() {
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            updateCheckboxStyles();
            updateProcessButton();
        }

        function deselectAll() {
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            updateCheckboxStyles();
            updateProcessButton();
        }

        function getSelectedColumns() {
            const selected = ['Bygningsnr.']; // Always include building number
            document.querySelectorAll('.column-checkbox input[type="checkbox"]').forEach(cb => {
                if (cb.checked) {
                    selected.push(cb.value);
                }
            });
            return selected;
        }

        // Initialize checkbox styles
        updateCheckboxStyles();

        
        // OIS helper (open PDF by pasting an OIS link)
        function extractBFEFromOisUrl(url) {
            if (!url) return null;
            // common pattern: https://ois.dk/search/<BFE>/...
            let m = url.match(/\/search\/(\d{6,})\b/);
            if (m && m[1]) return m[1];
            // bfe query param
            try {
                const u = new URL(url);
                const bfe = u.searchParams.get('bfe');
                if (bfe && /^\d{6,}$/.test(bfe)) return bfe;
            } catch (e) {}
            // any long number in the url as fallback
            m = url.match(/\b(\d{6,})\b/);
            if (m && m[1]) return m[1];
            return null;
        }


        // Batch BFE parsing (accepts newline/comma/space and ignores non-digits)
        function parseBFEList(text) {
            const m = (text || '').match(/\d{4,20}/g) || [];
            // unique while preserving order
            const seen = new Set();
            const out = [];
            for (const x of m) {
                if (!seen.has(x)) { seen.add(x); out.push(x); }
            }
            return out;
        }


        // Small helper: awaitable delay
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function isRetryableFetchError(err) {
            const msg = String((err && err.message) ? err.message : err).toLowerCase();
            // Typical transient issues: proxy 502 with upstream 524, network interruptions, partial transfers
            return (
                msg.includes('proxy-fejl (502') ||
                msg.includes('proxy-fejl (520') ||
                msg.includes('proxy-fejl (524') ||
                msg.includes('proxy-fejl (429') ||
                msg.includes('bad gateway') ||
                msg.includes('upstream error') ||
                msg.includes('failed to fetch') ||
                msg.includes('networkerror') ||
                msg.includes('content_length_mismatch') ||
                msg.includes('content length mismatch') ||
                msg.includes('timeout') || msg.includes('aborted') || msg.includes('abort')
            );
        }

        async function fetchPdfViaProxyWithRetry(cleanBase, bfe, opts = {}) {
            const maxAttempts = opts.maxAttempts ?? 3;
            const baseDelayMs = opts.baseDelayMs ?? 350;   // gentle pacing to avoid upstream bursts
            const backoffStartMs = opts.backoffStartMs ?? 900;

            let lastErr = null;
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                let tId = null;
                try {
                    const proxyUrl = `${cleanBase}/?bfe=${encodeURIComponent(bfe)}`;

                    // no-store to avoid odd caching behaviours during retries
                    const ac = new AbortController();
                    const timeoutMs = opts.timeoutMs ?? 20000; // 20s per attempt (helps avoid long hangs)
                    tId = setTimeout(() => ac.abort('timeout'), timeoutMs);

                    const res = await fetch(proxyUrl, { method: 'GET', cache: 'no-store', signal: ac.signal });
                    if (tId) { clearTimeout(tId); tId = null; }

                    if (!res.ok) {
                        const t = await res.text().catch(() => '');
                        throw new Error(`Proxy-fejl (${res.status}): ${t.slice(0, 160)}`);
                    }

                    const buf = await res.arrayBuffer();

                    // Validate PDF header
                    const u8 = new Uint8Array(buf);
                    const head = String.fromCharCode(...u8.slice(0, 4));
                    if (head !== '%PDF') {
                        let snippet = '';
                        try { snippet = new TextDecoder('utf-8').decode(u8.slice(0, 220)); } catch (e) {}
                        throw new Error('Ikke PDF. Start: ' + (snippet || head));
                    }

                    // Gentle spacing between successful requests too
                    if (baseDelayMs > 0) await sleep(baseDelayMs);

                    return buf;
                } catch (err) {
                    if (tId) { try { clearTimeout(tId); } catch (e) {} tId = null; }
                    lastErr = err;

                    const retryable = isRetryableFetchError(err);
                    if (!retryable || attempt === maxAttempts) break;

                    // Exponential backoff with jitter
                    const wait = Math.min(
                        15000,
                        (backoffStartMs * Math.pow(2, attempt - 1)) + Math.floor(Math.random() * 350)
                    );

                    if (bfeBatchHint) {
                        bfeBatchHint.textContent = `Midlertidig fejl for ${bfe} (fors√∏g ${attempt}/${maxAttempts}). Pr√∏ver igen om ~${Math.round(wait/1000)}s...`;
                    }

                    await sleep(wait);
                }
            }

            throw lastErr || new Error('Ukendt fejl ved hentning');
        }


        function bfeToOisSearchUrl(bfe) {
            return `https://ois.dk/search/${bfe}/sfe/`;
        }

        function bfeToPdfUrl(bfe) {
            return `https://ois.dk/bbrmeddelelse/get?bfe=${bfe}`;
        }


        function extractBFEFromFilename(name) {
            const m = String(name || '').match(/\d{4,20}/);
            return m ? m[0] : '';
        }


        let batchOpenQueue = [];
        let batchOpenIndex = 0;
        function resetBatchOpenQueue() {
            batchOpenQueue = parseBFEList(bfeBatchInput ? bfeBatchInput.value : '');
            batchOpenIndex = 0;
        }



        if (oisOpenPdfBtn && oisLinkInput) {
            oisOpenPdfBtn.addEventListener('click', () => {
                const bfe = extractBFEFromOisUrl(oisLinkInput.value.trim());
                if (!bfe) {
                    if (oisHint) oisHint.textContent = 'Kunne ikke finde et BFE-nummer i linket. Tjek at det ligner https://ois.dk/search/10171611/...';
                    return;
                }
                const pdfUrl = `https://ois.dk/bbrmeddelelse/get?bfe=${bfe}`;
                if (oisHint) oisHint.textContent = `√Öbner PDF: ${pdfUrl}`;
                window.open(pdfUrl, '_blank', 'noopener');
            });
        }


        // OIS: fetch PDF via proxy and add it to the file list, then auto-run preview
        if (oisFetchExtractBtn && oisLinkInput) {
            oisFetchExtractBtn.addEventListener('click', async () => {
                const bfe = extractBFEFromOisUrl(oisLinkInput.value.trim());
                if (!bfe) {
                    if (oisHint) oisHint.textContent = 'Kunne ikke finde et BFE-nummer i linket. Tjek at det ligner https://ois.dk/search/10171611/...';
                    return;
                }

                const proxyBase = getProxyBase();
                if (!proxyBase) {
                    if (oisHint) oisHint.textContent = 'Indtast jeres Cloudflare Worker proxy-URL og tryk Gem proxy f√∏rst.';
                    return;
                }

                const cleanBase = proxyBase.replace(/\/+$/, '');
                const proxyUrl = `${cleanBase}/?bfe=${encodeURIComponent(bfe)}`;

                try {
                    oisFetchExtractBtn.disabled = true;
                    oisFetchExtractBtn.style.opacity = '0.7';
                    if (oisHint) oisHint.textContent = 'Henter PDF via proxy...';

                    const res = await fetch(proxyUrl, { method: 'GET', cache: 'no-store' });
                    if (!res.ok) {
                        const t = await res.text().catch(() => '');
                        throw new Error(`Proxy-fejl (${res.status}): ${t.slice(0, 120)}`);
                    }
                    const ct = (res.headers.get('content-type') || '').toLowerCase();
                    if (!ct.includes('pdf')) {
                        // still try to read as binary, but warn
                        console.warn('Proxy response content-type:', ct);
                    }
                    const buf = await res.arrayBuffer();
                    // Validate that the response is actually a PDF (starts with %PDF)
                    try {
                        const u8 = new Uint8Array(buf);
                        const head = String.fromCharCode(...u8.slice(0, 4));
                        if (head !== '%PDF') {
                            // Try to decode a short snippet for debugging (likely HTML error)
                            let snippet = '';
                            try { snippet = new TextDecoder('utf-8').decode(u8.slice(0, 200)); } catch (e) {}
                            throw new Error('Proxy returnerede ikke en PDF. Start p√• svar: ' + (snippet || head));
                        }
                    } catch (e) {
                        throw e;
                    }

                    const file = new File([buf], `bbr_${bfe}.pdf`, { type: 'application/pdf' });

                    // Add to existing uploader list
                    handleFiles([file]);

                    // Auto-run preview if possible
                    const hasSelectedColumns = document.querySelectorAll('.column-checkbox input[type="checkbox"]:checked').length > 0;
                    if (!hasSelectedColumns) {
                        if (oisHint) oisHint.textContent = 'PDF hentet. V√¶lg kolonner f√∏rst, og tryk derefter Preview Data.';
                        return;
                    }

                    if (oisHint) oisHint.textContent = 'PDF hentet.';
                    // Trigger the same flow as clicking Preview Data
                    processBtn.click();

                } catch (err) {
                    console.error(err);
                    if (oisHint) oisHint.textContent = 'Kunne ikke hente PDF via proxy: ' + (err && err.message ? err.message : err);
                } finally {
                    oisFetchExtractBtn.disabled = false;
                    oisFetchExtractBtn.style.opacity = '1';
                }
            });
        }



        // Batch: copy OIS search links to clipboard
        if (bfeBatchLinksBtn && bfeBatchInput) {
            bfeBatchLinksBtn.addEventListener('click', async () => {
                const bfes = parseBFEList(bfeBatchInput.value);
                if (!bfes.length) {
                    if (bfeBatchHint) bfeBatchHint.textContent = 'Inds√¶t mindst √©t BFE-nummer f√∏rst.';
                    return;
                }
                const text = bfes.map(b => bfeToOisSearchUrl(b)).join('\n');
                try {
                    await navigator.clipboard.writeText(text);
                    if (bfeBatchHint) bfeBatchHint.textContent = `Kopieret ${bfes.length} links til udklipsholderen.`;
                } catch (e) {
                    // Fallback: show text in hint
                    if (bfeBatchHint) bfeBatchHint.textContent = 'Kunne ikke kopiere automatisk. Marker og kopi√©r manuelt fra her: ' + text;
                }
            });
        }

        // Batch: open the next OIS search page (helps with popup blockers)
        if (bfeBatchOpenBtn && bfeBatchInput) {
            bfeBatchOpenBtn.addEventListener('click', () => {
                if (!batchOpenQueue.length || batchOpenIndex >= batchOpenQueue.length) {
                    resetBatchOpenQueue();
                }
                if (!batchOpenQueue.length) {
                    if (bfeBatchHint) bfeBatchHint.textContent = 'Inds√¶t mindst √©t BFE-nummer f√∏rst.';
                    return;
                }
                const bfe = batchOpenQueue[batchOpenIndex++];
                const url = bfeToOisSearchUrl(bfe);
                window.open(url, '_blank', 'noopener');
                if (bfeBatchHint) bfeBatchHint.textContent = `√Öbner (${batchOpenIndex}/${batchOpenQueue.length}): ${url}`;
            });
        }

        // Batch: fetch many PDFs via the existing proxy, add them, then (optionally) auto-run preview
        if (bfeBatchFetchBtn && bfeBatchInput) {
            bfeBatchFetchBtn.addEventListener('click', async () => {
                const bfes = parseBFEList(bfeBatchInput.value);
                if (!bfes.length) {
                    if (bfeBatchHint) bfeBatchHint.textContent = 'Inds√¶t mindst √©t BFE-nummer f√∏rst.';
                    return;
                }

                const proxyBase = getProxyBase();
                if (!proxyBase) {
                    if (bfeBatchHint) bfeBatchHint.textContent = 'Proxy-URL mangler.';
                    return;
                }
                const cleanBase = proxyBase.replace(/\/+$/, '');

                // UI state
                bfeBatchFetchBtn.disabled = true;
                bfeBatchFetchBtn.style.opacity = '0.7';
                if (bfeBatchHint) bfeBatchHint.textContent = `Henter ${bfes.length} PDF'er via proxy...`;
                showProgress(true);

                const fetched = [];
                const failed = [];

                // If columns are selected, we can pipeline parsing while downloading
                const selectedColumns = getSelectedColumns();
                const hasSelectedColumns = selectedColumns && selectedColumns.length > 0;
                if (hasSelectedColumns) {
                    startPipeline(selectedColumns, bfes.length);
                }


                // Turbo: higher concurrency for both fetching and parsing (still with retries/backoff)
                const FETCH_CONCURRENCY = 10;
                const PARSE_CONCURRENCY = 2;

                const fetchQueue = bfes.slice();
                const parseQueue = [];
                let fetchedCount = 0;
                let parsedCount = 0;
                let fetchDone = false;

                function pushParse(fileObj) {
                    parseQueue.push(fileObj);
                }

                async function fetchWorker(workerId) {
                    while (fetchQueue.length) {
                        const bfe = fetchQueue.shift();
                        try {
                            updateProgressFetch((fetchedCount / bfes.length) * 100, `Henter ${bfe} (${fetchedCount + 1}/${bfes.length})...`);
                            updateProgressParse((parsedCount / bfes.length) * 100, `Indl√¶st ${parsedCount}/${bfes.length}`);

                            let buf = cacheGet(bfe);
                            if (!buf) {
                                buf = await fetchPdfViaProxyWithRetry(cleanBase, bfe, {
                                    maxAttempts: 3,
                                    baseDelayMs: 0,        // fastest pacing
                                    backoffStartMs: 900,
                                });
                                cachePut(bfe, buf);
                            }

                            const fileObj = new File([buf], `bbr_${bfe}.pdf`, { type: 'application/pdf' });
                            fetched.push(fileObj);
                            clearFetchFailure(bfe);

                            if (hasSelectedColumns) {
                                pushParse(fileObj);
                            }
                        } catch (err) {
                            console.warn('Batch fetch fejl for', bfe, err);
                            failed.push({ bfe, err: (err && err.message) ? err.message : String(err) });
                            addFetchFailure(bfe, (err && err.message) ? err.message : String(err));
                        } finally {
                            fetchedCount += 1;
                            updateProgressFetch((fetchedCount / bfes.length) * 100, `Hentet ${fetchedCount}/${bfes.length}`);
                            updateProgressParse((parsedCount / bfes.length) * 100, `Indl√¶st ${parsedCount}/${bfes.length}`);
                        }
                    }
                }

                async function parseWorker(workerId) {
                    while (!fetchDone || parseQueue.length) {
                        const fileObj = parseQueue.shift();
                        if (!fileObj) {
                            await sleep(60);
                            continue;
                        }
                        try {
                            updateProgressParse((parsedCount / bfes.length) * 100, `Indl√¶ser ${fileObj.name} (${parsedCount + 1}/${bfes.length})...`);
                            updateProgressFetch((fetchedCount / bfes.length) * 100, `Hentet ${fetchedCount}/${bfes.length}`);
                            await pipelineConsumeFile(fileObj);
                        } catch (e) {
                            const bfeGuess = extractBFEFromFilename(fileObj && fileObj.name);
                            console.warn('Pipeline parse fejl for', bfeGuess || (fileObj && fileObj.name), e);
                            addFetchFailure(bfeGuess || (fileObj && fileObj.name) || 'Ukendt', (e && e.message) ? e.message : String(e));
                        } finally {
                            parsedCount += 1;
                            updateProgressFetch((fetchedCount / bfes.length) * 100, `Hentet ${fetchedCount}/${bfes.length}`);
                            updateProgressParse((parsedCount / bfes.length) * 100, `Indl√¶st ${parsedCount}/${bfes.length}`);
                        }
                    }
                }

                const nFetchers = Math.min(FETCH_CONCURRENCY, fetchQueue.length || 0);
                const fetchers = Array.from({ length: nFetchers }, (_, i) => fetchWorker(i + 1));

                const nParsers = hasSelectedColumns ? Math.min(PARSE_CONCURRENCY, bfes.length) : 0;
                const parsers = hasSelectedColumns ? Array.from({ length: nParsers }, (_, i) => parseWorker(i + 1)) : [];

                await Promise.all(fetchers);
                fetchDone = true;
                if (hasSelectedColumns) await Promise.all(parsers);

                // Add all fetched files in one go (avoid re-render for each file)
                if (fetched.length) {
                    const pdfFiles = fetched.filter(f => f.name.toLowerCase().endsWith('.pdf'));
                    selectedFiles = [...selectedFiles, ...pdfFiles];
                    renderFileList();
                    updateProcessButton();
                }

                updateProgressFetch(100, `F√¶rdig. Hentet: ${fetched.length}. Fejl: ${failed.length}.`);
                if (hasSelectedColumns) updateProgressParse(100, `F√¶rdig. Indl√¶st: ${parsedCount}/${bfes.length}`);
                showProgress(false);

                if (bfeBatchHint) {
                    if (!failed.length) {
                        bfeBatchHint.textContent = `F√¶rdig. Hentet ${fetched.length} PDF'er.`;
                    } else {
                        bfeBatchHint.textContent = `F√¶rdig. Hentet ${fetched.length} PDF'er. Fejl p√• ${failed.length} (se console for detaljer).`;
                    }
                }

                // Auto-run preview / processing when columns are selected
                if (hasSelectedColumns) {
                    // If we used the pipeline, finalize and show preview directly
                    const pd = finalizePipeline();
                    if (pd) {
                        updateProgressParse(95, 'Forbereder preview...');
                        showProgress(false);
                        showStatus('success', 'F√¶rdig (pipeline). √Öbner preview...');
                        showPreview();
                    } else if (selectedFiles.length) {
                        // Fallback to normal processing
                        processBtn.click();
                    }
                }

                // reset UI
                bfeBatchFetchBtn.disabled = false;
                bfeBatchFetchBtn.style.opacity = '1';
            });
        }

        // Upload area events
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            const pdfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.pdf'));
            selectedFiles = [...selectedFiles, ...pdfFiles];
            renderFileList();
            updateProcessButton();
        }

        function renderFileList() {
            if (selectedFiles.length === 0) {
                fileList.innerHTML = '';
                return;
            }

            fileList.innerHTML = selectedFiles.map((file, index) => `
                <div class="file-item">
                    <span class="file-name">üìÑ ${file.name}</span>
                    <span class="file-remove" onclick="removeFile(${index})">‚úï</span>
                </div>
            `).join('');
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFileList();
            updateProcessButton();
        }

        function updateProcessButton() {
            const hasSelectedColumns = document.querySelectorAll('.column-checkbox input[type="checkbox"]:checked').length > 0;
            processBtn.disabled = !hasSelectedColumns || selectedFiles.length === 0;
        }

        // Main processing function
        
        async function processSingleFile(file, selectedColumns, allData, grandTotals, i, totalCount) {
            updateProgress((i / Math.max(1, totalCount)) * 100, `Behandler ${file.name}...`);

            let buildings, sheetName, propertyMeta;
            try {
                ({ buildings, sheetName, propertyMeta } = await extractPDFData(file, selectedColumns));
            } catch (e) {
                const bfeGuess = extractBFEFromFilename(file && file.name);
                console.warn('Kunne ikke behandle PDF for', bfeGuess || (file && file.name), e);
                addFetchFailure(bfeGuess || (file && file.name) || 'Ukendt', (e && e.message) ? e.message : String(e));
                return;
            }

            // Filter columns based on user selection
            const filteredBuildings = buildings.map(building => {
                const filtered = {};
                selectedColumns.forEach(col => {
                    filtered[col] = (building[col] ?? '');
                });
                return filtered;
            });

            // Calculate totals for this sheet
            const totalRow = {};
            totalRow['Bygningsnr.'] = sheetName;
            totalRow['Ejendomsnummer (BFE-nr.)'] = (propertyMeta && propertyMeta['Ejendomsnummer (BFE-nr.)'] != null)
                ? propertyMeta['Ejendomsnummer (BFE-nr.)']
                : (extractBFEFromFilename(file && file.name) || '');

            selectedColumns.forEach(col => {
                if (col === 'Bygningsnr.') return;

                if (typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(col)) {
                    const sum = filteredBuildings.reduce((acc, b) => {
                        const v = b[col];
                        const val = (typeof v === 'number') ? v : (parseInt(v, 10) || 0);
                        return acc + val;
                    }, 0);
                    totalRow[col] = sum;
                    return;
                }

                if (col === '_Confidence') {
                    const vals = filteredBuildings
                        .map(b => (typeof b[col] === 'number' ? b[col] : parseInt(b[col], 10)))
                        .filter(v => typeof v === 'number' && !isNaN(v));
                    totalRow[col] = vals.length ? Math.round(vals.reduce((a, x) => a + x, 0) / vals.length) : '-';
                    return;
                }

                if (col === '_Warnings') { totalRow[col] = '-'; return; }

                totalRow[col] = '-';
            });

            const rowTotal = Object.keys(totalRow)
                .filter(k => k !== 'Bygningsnr.' && k !== 'Total')
                .reduce((acc, k) => acc + ((typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(k)) ? (parseInt(totalRow[k], 10) || 0) : 0), 0);
            totalRow['Total'] = rowTotal;

            grandTotals.push(totalRow);
            filteredBuildings.push(totalRow);

            allData.push({
                sheetName: sheetName,
                propertyMeta: propertyMeta,
                data: filteredBuildings
            });
        }

processBtn.addEventListener('click', async () => {
        try {

            try {
                if (!window.pdfjsLib) {
                    showStatus('error', 'PDF.js kunne ikke indl√¶ses. Det skyldes ofte at CDNs er blokeret p√• netv√¶rket (firma-sikkerhed).\n\nL√∏sning: Host pdf.min.js + pdf.worker.min.js sammen med siden (samme dom√¶ne) eller bed IT tillade cdnjs.cloudflare.com.');
                    return;
                }
                showStatus('info', 'Behandler PDFer...');
                showProgress(true);
                processBtn.disabled = true;

                const selectedColumns = getSelectedColumns();
                const allData = [];
                const grandTotals = [];

                const PARSE_CONCURRENCY = 2;
                const pQueue = selectedFiles.slice();
                let pDone = 0;

                async function pWorker() {
                    while (pQueue.length) {
                        const file = pQueue.shift();
                        await processSingleFile(file, selectedColumns, allData, grandTotals, pDone, selectedFiles.length);
                        pDone += 1;
                        await sleep(0); // yield
                    }
                }

                const pWorkers = Array.from({ length: Math.min(PARSE_CONCURRENCY, pQueue.length || 0) }, () => pWorker());
                await Promise.all(pWorkers);

                updateProgress(95, 'Forbereder preview...');

                // Create grand total sheet
                const finalTotalRow = {};
                finalTotalRow['Bygningsnr.'] = 'Final Total';
                finalTotalRow['Ejendomsnummer (BFE-nr.)'] = '-';
                
                selectedColumns.forEach(col => {
                    if (col === 'Bygningsnr.') return;

                    if (typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(col)) {
                        const sum = grandTotals.reduce((acc, row) => acc + (parseInt(row[col], 10) || 0), 0);
                        finalTotalRow[col] = sum;
                        return;
                    }

                    if (col === '_Confidence') {
                        const vals = grandTotals
                            .map(r => (typeof r[col] === 'number' ? r[col] : parseInt(r[col], 10)))
                            .filter(v => typeof v === 'number' && !isNaN(v));
                        finalTotalRow[col] = vals.length ? Math.round(vals.reduce((a, x) => a + x, 0) / vals.length) : '-';
                        return;
                    }

                    if (col === '_Warnings') {
                        finalTotalRow[col] = '-';
                        return;
                    }

                    finalTotalRow[col] = '-';
                });

                const finalRowTotal = Object.keys(finalTotalRow)
                    .filter(k => k !== 'Bygningsnr.' && k !== 'Total')
                    .reduce((acc, k) => acc + ((typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(k)) ? (parseInt(finalTotalRow[k], 10) || 0) : 0), 0);
                finalTotalRow['Total'] = finalRowTotal;

                grandTotals.push(finalTotalRow);

                // Store data globally
                processedData = {
                    allData: allData,
                    grandTotals: grandTotals,
                    selectedColumns: selectedColumns
                };

                updateProgress(100, 'F√¶rdig!');
                showStatus('success', `‚úì Data behandlet! ${selectedFiles.length} PDFer klar til preview.`);
                if (typeof oisHint !== 'undefined' && oisHint) oisHint.textContent = '';
                
                setTimeout(() => {
                    showProgress(false);
                    processBtn.disabled = false;
                    showPreview();
                }, 500);

            } catch (error) {
                console.error('Error:', error);
                showStatus('error', 'Fejl: ' + error.message);
                showProgress(false);
                processBtn.disabled = false;
            }
        
        } catch (e) {
            console.error('Klik fejl:', e);
            showStatus('Fejl: ' + (e && e.message ? e.message : e), 'error');
        }
});

        async function extractPDFData(file, selectedColumns) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            let allText = '';
            
            // Extract text from all pages
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                let pageText = textContent.items.map(item => item.str).join(' ');
                pageText = normalizeText(pageText);
                allText += pageText + '\n';
            }

            // Extract sheet name (BBR address)
            let sheetName = 'Unknown';

            // In newer BBR PDFs the address often appears as "BBR-adresse: <vejnavn> <nr>, <postnr> <by>"
            // We only want the short street + number for the tab name (e.g. "Seminarievej 23")
            const addrPatterns = [
              // Handle variants like "BBR-adresse", "BBR adresse", and "BBR - adresse" (spaces around hyphen) incl. en-dash/em-dash
              /BBR\s*[-‚Äì‚Äî]?\s*adresse\s*:?\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|\s+Postnr\.|\s+By\b|$)/i,

              // Variants around the ground/location section (with or without spaces)
              /Oplysninger\s*om\s*grund\s*.*?Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /Oplysningeromgrund\s*.*?Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /Beliggenhed\s*Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /Beliggenhedsadresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,

              /Ejendommens\s*adresse\s*:?\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,
              /Ejendommensadresse\s*:?\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i,

              // Generic fallback (least specific)
              /Adresse\s*:\s*([A-Za-z√Ü√ò√Ö√¶√∏√•0-9 .,'-]+?\d+[A-Za-z]?)(?=\s*,|\s+\d{4}\s|$)/i
            ];

            for (const pat of addrPatterns) {
              const m = allText.match(pat);
              if (m && m[1]) {
                const cand = m[1].replace(/\s+/g, ' ').trim();
                if (looksLikeStreetAddress(cand)) {
                  sheetName = cand;
                  break;
                }
              }
            }

            
            // If we still don't have an address, try a heuristic with postnr/by:
            // "<vejnavn> <nr>, <postnr> <by>"
            if (!sheetName || sheetName === 'Unknown') {
              const pm = allText.match(/([A-Za-z√Ü√ò√Ö√¶√∏√•][A-Za-z√Ü√ò√Ö√¶√∏√• .,'-]{2,}\s+\d+[A-Za-z]?)\s*,?\s*(\d{4})\s+([A-Za-z√Ü√ò√Ö√¶√∏√• .,'-]{2,})/i);
              if (pm && pm[1]) {
                const cand = pm[1].replace(/\s+/g, ' ').trim();
                if (looksLikeStreetAddress(cand)) sheetName = cand;
              }
            }
// Keep tab names reasonably short and Excel-friendly
            sheetName = sheetName.replace(/[\\/:\?\*\[\]]/g, '').trim();
            if (sheetName.length > 60) sheetName = sheetName.slice(0, 60).trim();

            
            
// Parse building data
            const bfe = extractBFE(allText);

            // If address extraction failed, fall back to BFE so we don't show 'Ukendt'
            if ((!sheetName || sheetName === 'Unknown') && bfe) sheetName = `BFE ${bfe}`;

            try { const ab = document.getElementById('addressBadge'); if (ab) ab.textContent = (sheetName && sheetName !== 'Unknown') ? sheetName : 'Ukendt'; } catch(e) {}



            // Property meta (shown in separate table)
            const propertyMeta = {
                'Kommunenummer': extractKommunenummer(allText),
                'Matrikelnummer': extractMatrikelnummer(allText),
                'Ejendomsnummer (BFE-nr.)': bfe
            };

            // Parse building data
            const wantedColsSet = (Array.isArray(selectedColumns) && selectedColumns.length) ? new Set(selectedColumns) : null;
            const buildings = parseBuildings(allText, { bfe }, wantedColsSet);

            return { buildings, sheetName, propertyMeta };
        }

        
        function parseBuildings(text, meta, wantedCols) {
            const buildings = [];

            // Collect building markers from both old and new layouts
            // Old: "Bygningsnr.: 7"
            // New: "Bygning 7"
            const markers = [];
            const reOld = /Bygningsnr\.\s*:\s*(\d+)/g;
            const reNew = /\bBygning\s+(\d+)\b/g;

            let m;
            while ((m = reOld.exec(text)) !== null) {
                markers.push({ num: parseInt(m[1], 10), pos: m.index });
            }
            while ((m = reNew.exec(text)) !== null) {
                markers.push({ num: parseInt(m[1], 10), pos: m.index });
            }

            // sort by position and dedupe near-duplicates
            markers.sort((a, b) => a.pos - b.pos);
            const deduped = [];
            for (const mk of markers) {
                const last = deduped[deduped.length - 1];
                if (last && last.num === mk.num && Math.abs(last.pos - mk.pos) < 80) continue;
                deduped.push(mk);
            }

            const debugOn = document.getElementById('debugConsole')?.checked;
            const wantSet = (wantedCols && (wantedCols instanceof Set)) ? wantedCols
                           : (Array.isArray(wantedCols) ? new Set(wantedCols) : null);
            const wantCol = (col) => !wantSet || wantSet.has(col);

            if (debugOn) {
                console.log('=== PARSE DEBUG ===');
                console.log('Building markers found:', deduped.map(b => b.num));
            }

            function matchFirstNumber(section, patterns) {
                for (const pat of patterns) {
                    const mm = section.match(pat);
                    if (mm && mm[1] !== undefined) return parseInt(mm[1], 10);
                }
                return undefined;
            }

            function matchTextField(section, patterns) {
                for (const pat of patterns) {
                    const mm = section.match(pat);
                    if (mm && mm[1]) {
                        let v = mm[1].trim();
                        // Cut off if the capture accidentally includes the next label (new PDF layout often concatenates words)
                        const stopTokens = [
                            'supplerendeyderv√¶gsmateriale',
                            'supplerendetagd√¶kningsmateriale',
                            'varmeforsyning',
                            'bygningensvarmeinstallation',
                            'opvarmningsmiddel',
                            'energiplan',
                            'ejerforhold',
                            'kildetil',
                            'bbr-meddelelse',
                            'udskriftsdato',
                            'side'
                        ];
                        const vLower = v.toLowerCase();
                        let cutIdx = v.length;
                        for (const tok of stopTokens) {
                            const j = vLower.indexOf(tok);
                            if (j !== -1 && j < cutIdx) cutIdx = j;
                        }
                        v = v.slice(0, cutIdx).trim();
                        // remove trailing punctuation
                        v = v.replace(/[\s,;:.-]+$/g, '').trim();
                        return v || undefined;
                    }
                }
                return undefined;
            }

            function pickClosestYear(section, anchorIdxInSection) {
                // Prefer "Sikker Opf√∏relses√•r" then "Opf√∏relses√•r"
                const yearMatches = [];
                const yrRe = /(Sikker\s+Opf√∏relses√•r|Opf√∏relses√•r)\s*:\s*(\d{4})/gi;
                let ym;
                while ((ym = yrRe.exec(section)) !== null) {
                    yearMatches.push({ label: ym[1], year: parseInt(ym[2], 10), idx: ym.index });
                }
                if (!yearMatches.length) return undefined;

                // Prefer matches BEFORE anchor, closest distance; else closest after
                let best = null;
                for (const y of yearMatches) {
                    const dist = y.idx - anchorIdxInSection;
                    const score = (dist <= 0 ? Math.abs(dist) : 100000 + dist) + (String(y.label).toLowerCase().includes('sikker') ? -50 : 0);
                    if (!best || score < best.score) best = { ...y, score };
                }
                return best ? best.year : undefined;
            }

                        // Pre-scan Bebygget areal in the FULL text and assign each match to the nearest building marker
            // by looking for the last "Bygning X" / "Bygningsnr.: X" within a window before the match.
            const bebyggetByBuilding = new Map();
            if (wantCol('Bebygget areal')) {
            const bebyggetMatches = [];
            const bebyggetRe = /(Bebygget\s*areal|Bebyggetareal)\s*(?::|\s)\s*(\d{1,6})(?:\s*(?:m2|m¬≤))?/gi;
            let bm;
            while ((bm = bebyggetRe.exec(text)) !== null) {
                bebyggetMatches.push({ idx: bm.index, val: parseInt(bm[2], 10) });
            }
            for (const b of bebyggetMatches) {
                const lookBackStart = Math.max(0, b.idx - 900);
                const windowText = text.substring(lookBackStart, b.idx);
                let owner = null;

                // find LAST marker in the lookback window
                const markerRe = /(Bygningsnr\.\s*:\s*(\d+))|\bBygning\s+(\d+)\b/gi;
                let mm;
                while ((mm = markerRe.exec(windowText)) !== null) {
                    owner = parseInt(mm[2] || mm[3], 10);
                }

                if (owner !== null && !Number.isNaN(owner)) {
                    // If multiple values map to same building, keep the one closest to its marker later (overwrite is fine).
                    bebyggetByBuilding.set(owner, b.val);
                }
            }


            
            }

// Pre-scan Erhvervsareal in the FULL text and assign each match to the nearest building marker
            // by looking for the last "Bygning X" / "Bygningsnr.: X" within a window before the match.
            const erhvervByBuilding = new Map();
            if (wantCol('Erhvervsareal')) {
            const erhvervMatches = [];
            const erhvervRe = /(Bygningens\s*samlede\s*erhvervsareal)\s*(?::|\s)\s*(\d{1,7})(?:\s*(?:m\s*(?:2|¬≤)))?/gi;
            let em;
            while ((em = erhvervRe.exec(text)) !== null) {
                erhvervMatches.push({ idx: em.index, val: parseInt(em[2], 10) });
            }
            for (const e of erhvervMatches) {
                const lookBackStart = Math.max(0, e.idx - 900);
                const windowText = text.substring(lookBackStart, e.idx);
                let owner = null;

                // find LAST marker in the lookback window
                const markerRe = /(Bygningsnr\.\s*:\s*(\d+))|\bBygning\s+(\d+)\b/gi;
                let mm;
                while ((mm = markerRe.exec(windowText)) !== null) {
                    owner = parseInt(mm[2] || mm[3], 10);
                }

                if (owner !== null && !Number.isNaN(owner)) {
                    erhvervByBuilding.set(owner, e.val);
                }
            }


            }

for (let i = 0; i < deduped.length; i++) {
                const cur = deduped[i];
                const prev = deduped[i - 1];
                const next = deduped[i + 1];

                const preContext = 0; // avoid leaking unit/previous-building values into this building
                const startPos = Math.max(0, cur.pos - preContext);
                let endPos = next ? next.pos : text.length;
                let jumpTo = i;
                if (next && next.num === cur.num) {
                    // Some PDFs repeat the same "Bygning X" marker (e.g., heading + unit section).
                    // Merge consecutive same-number blocks so fields (like unit areas) stay with the correct building.
                    let k = i + 1;
                    while (k < deduped.length && deduped[k].num === cur.num) k++;
                    endPos = (k < deduped.length) ? deduped[k].pos : text.length;
                    jumpTo = k - 1;
                }
                const section = text.substring(startPos, endPos);

                const building = { 'Bygningsnr.': cur.num };

                // Property-level field (same for all buildings)
                if (wantCol('Ejendomsnummer (BFE-nr.)')) { if (meta && meta.bfe) building['Ejendomsnummer (BFE-nr.)'] = meta.bfe; }


                // --- Areal-felter (old + new labels) ---
                if (wantCol('Samlet bygningsareal')) {
                building['Samlet bygningsareal'] = matchFirstNumber(section, [
                    /Samlet bygningsareal[^\d]{0,40}(\d{1,6})/i,
                    /Samletbygningsareal[^\d]{0,40}(\d{1,6})/i,
                    /Bygningens samlede etageareal[^\d]{0,40}(\d{1,6})/i,
                    /Bygningenssamledeetageareal[^\d]{0,40}(\d{1,6})/i,
                ]);
                }

                if (wantCol('Samlet k√¶lderareal')) {
                building['Samlet k√¶lderareal'] = matchFirstNumber(section, [
                    /Samlet k√¶lderareal[^\d]{0,30}(\d{1,6})/i,
                    /Samletk√¶lderareal[^\d]{0,30}(\d{1,6})/i,
                    /K√¶lderens areal[^\d]{0,30}(\d{1,6})/i,
                    /K√¶lderensareal[^\d]{0,30}(\d{1,6})/i,
                ]);
                }

                if (wantCol('Samlet tagetageareal')) {
                building['Samlet tagetageareal'] = matchFirstNumber(section, [
                    /Samlet tagetageareal[^\d]{0,30}(\d{1,6})/i,
                    /Samlettagetageareal[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagens areal[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagensareal[^\d]{0,30}(\d{1,6})/i,
                    /Etagerens areal[^\d]{0,30}(\d{1,6})/i,
                    /Etagerensareal[^\d]{0,30}(\d{1,6})/i,
                ]);
                }

                if (wantCol('Heraf udnyttet tagetage')) {
                building['Heraf udnyttet tagetage'] = matchFirstNumber(section, [
                    /Heraf udnyttet tagetage[^\d]{0,30}(\d{1,6})/i,
                    /Herafudnyttettagetage[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagens udnyttede areal[^\d]{0,30}(\d{1,6})/i,
                    /Tagetagensudnyttedeareal[^\d]{0,30}(\d{1,6})/i,
                    /heraf\s*Tagetagens\s*udnyttede\s*areal[^\d]{0,30}(\d{1,6})/i,
                    /herafTagetagensudnyttedeareal[^\d]{0,30}(\d{1,6})/i,
                ]);
                }

                // Strict: avoid picking the "2" in "m2"
                const andet = section.match(/Samlet andet areal\s*:\s*(\d{1,6})(?!\s*(?:m2|m¬≤))/i);
                if (andet) if (wantCol('Samlet andet areal')) {
                building['Samlet andet areal'] = parseInt(andet[1], 10);
                }

                                if (wantCol('Bebygget areal')) {

                // Bebygget areal (new layout can be out-of-order). Prefer the pre-scanned mapping,
                                // otherwise fall back to matching inside this building section.
                                if (bebyggetByBuilding.has(cur.num)) {
                                    building['Bebygget areal'] = bebyggetByBuilding.get(cur.num);
                                } else {
                                    const beb = section.match(/Bebygget\s*areal\s*:\s*(\d{1,6})(?:\s*(?:m2|m¬≤))?/i)
                                             || section.match(/Bebygget\s*areal\s+(\d{1,6})(?:\s*(?:m2|m¬≤))?/i)
                                             || section.match(/Bebyggetareal\s*:\s*(\d{1,6})(?:\s*(?:m2|m¬≤))?/i)
                                             || section.match(/Bebyggetareal\s+(\d{1,6})(?:\s*(?:m2|m¬≤))?/i);
                                    if (beb) building['Bebygget areal'] = parseInt(beb[1], 10);
                                }
                
                                // If other areal fields exist, bebygget is fallback
                                const hasOtherAreal = ['Samlet bygningsareal','Samlet k√¶lderareal','Samlet tagetageareal','Heraf udnyttet tagetage','Samlet andet areal']
                                    .some(k => building[k] !== undefined);
                                if (hasOtherAreal && building['Bebygget areal'] !== undefined) {
                                    delete building['Bebygget areal'];
                                }
                
                

                }

                // --- Anden data ---
                if (wantCol('Opf√∏relses√•r')) {
                building['Opf√∏relses√•r'] = pickClosestYear(section, 0);
                }

                if (wantCol('Antal etager u. k√¶lder & tagetage')) {
                building['Antal etager u. k√¶lder & tagetage'] = matchFirstNumber(section, [
                    // Gammel label (med mellemrum)
                    /Antal etager u\.\s*k√¶lder\s*&\s*tagetage[^\d]{0,20}(\d{1,2})/i,
                    /Antal etager[^\d]{0,20}(\d{1,2})/i,
                    // Ny layout / normaliseret tekst (uden mellemrum)
                    /Antaletageru\.?(?:kaelder|k√¶lder)\s*&\s*tagetage[^\d]{0,20}(\d{1,2})/i,
                    /Antaletager[^\d]{0,20}(\d{1,2})/i,
                ]);
                }

                if (wantCol('Yderv√¶ggens materiale')) {
                building['Yderv√¶ggens materiale'] = trimAtParen(matchTextField(section, [
                    /Yderv√¶ggens materiale\s*:\s*([^]+?)(?=\s{2,}|Tagd√¶kningsmateriale|Varmeinstallation|Energiplan|$)/i,
                    /Yderv√¶gsmateriale\s*:\s*([^]+?)(?=\s{2,}|Tagd√¶kningsmateriale|Varmeinstallation|Energiplan|$)/i,
                ]));
                }

                if (wantCol('Tagd√¶kningsmateriale')) {
                building['Tagd√¶kningsmateriale'] = trimAtParen(matchTextField(section, [
                    /Tagd√¶kningsmateriale\s*:\s*([^]+?)(?=\s{2,}|Varmeinstallation|Energiplan|$)/i,
                ]));
                }


                if (wantCol('Bygningens anvendelse')) {
                building['Bygningens anvendelse'] = trimAtParen(matchTextField(section, [
                    /Bygningens\s+anvendelse\s*:\s*([^]+?)(?=\s{2,}|Opf√∏relses√•r|Antal\s+etager|Yderv√¶g|Tagd√¶kningsmateriale|Varmeinstallation|Energiplan|$)/i,
                    /Bygningensanvendelse\s*:\s*([^]+?)(?=\s{2,}|Opf√∏relses√•r|Antaletager|Yderv√¶g|Tagd√¶kningsmateriale|Varmeinstallation|Energiplan|$)/i,
                ]));
                }

                if (wantCol('Erhvervsareal')) {

                // Prefer explicit building-level label if present; otherwise fall back to summing unit-level "Enhedens erhvervsareal" within this building section.
                                if (erhvervByBuilding.has(cur.num)) {
                                    building['Erhvervsareal'] = erhvervByBuilding.get(cur.num);
                                } else {
                                    let erhv = matchFirstNumber(section, [
                                        /Bygningens\s*samlede\s*erhvervsareal[^\d]{0,30}(\d{1,7})(?:\s*(?:m\s*(?:2|¬≤)))?/i,
                                        /Bygningens\s*samlede\s*erhvervsareal\s*:\s*(\d{1,7})(?:\s*(?:m\s*(?:2|¬≤)))?/i,
                                    ]);
                
                                    if (erhv === undefined) {
                                        // Sum unit-level values that appear in the unit table for this building
                                        const unitRe = /Enhedens\s*erhvervsareal[^\d]{0,30}(\d{1,7})(?:\s*(?:m\s*(?:2|¬≤)))?/gi;
                                        let um;
                                        let sum = 0;
                                        let found = false;
                                        while ((um = unitRe.exec(section)) !== null) {
                                            sum += parseInt(um[1], 10);
                                            found = true;
                                        }
                                        if (found) erhv = sum;
                                    }
                
                                    building['Erhvervsareal'] = erhv;
                                }
                            }
                
                
                
                                // --- Quality ---
                                const warnOn = document.getElementById('qWarn')?.checked;
                                const confOn = document.getElementById('qConf')?.checked;
                
                                if (warnOn || confOn) {
                                    const warnings = [];
                                    let conf = 100;
                
                                    const arealKeys = ['Samlet bygningsareal','Samlet k√¶lderareal','Samlet tagetageareal','Heraf udnyttet tagetage','Samlet andet areal'];
                                    const foundAreal = arealKeys.some(k => building[k] !== undefined);
                                    if (!foundAreal && building['Bebygget areal'] === undefined) {
                                        warnings.push('Ingen areal-felter fundet');
                                        conf = Math.min(conf, 50);
                                    }
                                    if (!foundAreal && building['Bebygget areal'] !== undefined) {
                                        warnings.push('Kun "Bebygget areal" fundet (fallback)');
                                        conf = Math.min(conf, 80);
                                    }
                
                                    if (warnOn) if (wantCol('_Warnings')) {
                building['_Warnings'] = warnings.length ? warnings.join(' | ') : '-';
                }
                                    if (confOn) if (wantCol('_Confidence')) {
                building['_Confidence'] = conf;
                }
                                }
                
                                

                if (debugOn) {
                    console.log(`Building ${cur.num} (block length: ${section.length}):`);
                    console.log(`First 260 chars: ${section.substring(0, 260)}`);
                }

                i = jumpTo;

                buildings.push(building);
            }

            
            // Dedupe: the new layout sometimes contains repeated "Bygning X" markers.
            // Keep/merge the entry with the most extracted fields and drop empty duplicates.
            const byNum = new Map();

            function valueIsPresent(v) {
                if (v === undefined || v === null) return false;
                if (typeof v === 'string') {
                    const t = v.trim();
                    return t !== '' && t !== '-' && t.toLowerCase() !== 'unknown';
                }
                if (typeof v === 'number') {
                    // Treat 0 as "not present" for these extracted fields (0s are usually artifacts)
                    return v > 0;
                }
                return false;
            }

            function scoreBuilding(b) {
                let s = 0;
                for (const [k, v] of Object.entries(b)) {
                    if (k === 'Bygningsnr.') continue;
                    if (k.startsWith('_')) continue;
                    if (valueIsPresent(v)) s += 1;
                }
                return s;
            }

            for (const b of buildings) {
                const num = b['Bygningsnr.'];
                const sc = scoreBuilding(b);
                if (!byNum.has(num)) {
                    if (sc > 0) byNum.set(num, { b, sc });
                    else byNum.set(num, { b, sc }); // keep for now; may be replaced by a better one later
                    continue;
                }
                const cur = byNum.get(num);

                // Pick primary (higher score)
                let primary = cur.b, secondary = b;
                let pScore = cur.sc, sScore = sc;
                if (sScore > pScore) {
                    primary = b; secondary = cur.b;
                    pScore = sScore; sScore = cur.sc;
                }

                // Merge: fill missing fields in primary from secondary
                for (const [k, v] of Object.entries(secondary)) {
                    if (k === 'Bygningsnr.') continue;
                    if (!valueIsPresent(primary[k]) && valueIsPresent(v)) {
                        primary[k] = v;
                    }
                }

                byNum.set(num, { b: primary, sc: scoreBuilding(primary) });
            }

            // Drop entries that still have no extracted fields at all
            const out = Array.from(byNum.values())
                .map(x => x.b)
                .filter(b => scoreBuilding(b) > 0)
                .sort((a, b) => a['Bygningsnr.'] - b['Bygningsnr.']);

            return out;

        }

        function showStatus(type, message) {
            status.className = 'status ' + type;
            status.textContent = message;
            try { const sb = document.getElementById('statusBadge'); if (sb) sb.textContent = message; } catch(e) {}
        }

        function showProgress(show) {
            progress.style.display = show ? 'block' : 'none';
            if (!show) {
                if (progressFillFetch) progressFillFetch.style.width = '0%';
                if (progressFillParse) progressFillParse.style.width = '0%';
                if (progressTextFetch) progressTextFetch.textContent = '';
                if (progressTextParse) progressTextParse.textContent = '';
            } else {
                // reset on show
                if (progressFillFetch) progressFillFetch.style.width = '0%';
                if (progressFillParse) progressFillParse.style.width = '0%';
                if (progressTextFetch) progressTextFetch.textContent = '';
                if (progressTextParse) progressTextParse.textContent = '';
            }
        }

        function clampPct(p){ return Math.max(0, Math.min(100, p)); }

        function updateProgressFetch(percent, text) {
            if (!progressFillFetch || !progressTextFetch) return;
            progressFillFetch.style.width = clampPct(percent) + '%';
            if (text != null) progressTextFetch.textContent = text;
        }

        function updateProgressParse(percent, text) {
            if (!progressFillParse || !progressTextParse) return;
            progressFillParse.style.width = clampPct(percent) + '%';
            if (text != null) progressTextParse.textContent = text;
        }

        // Backwards-compatible: if old code calls updateProgress(), treat it as overall/parse
        function updateProgress(percent, text) {
            updateProgressParse(percent, text);
        }

        // Preview Modal Functions
        function showPreview() {
            if (!processedData) return;

            const modal = document.getElementById('previewModal');
            const tabsContainer = document.getElementById('sheetTabs');
            const contentsContainer = document.getElementById('sheetContents');

            // Clear previous content
            tabsContainer.innerHTML = '';
            contentsContainer.innerHTML = '';

            // Count duplicates so tabs become readable: "Adresse", "Adresse (2)", ...
            const nameCounts = new Map();

            // Create tabs and content for each sheet
            processedData.allData.forEach((sheet, index) => {
                const baseName = (sheet.sheetName || 'Unknown').trim() || 'Unknown';
                const prev = nameCounts.get(baseName) || 0;
                const next = prev + 1;
                nameCounts.set(baseName, next);
                const tabLabel = next > 1 ? `${baseName} (${next})` : baseName;

                // Create tab
                const tab = document.createElement('button');
                tab.className = 'sheet-tab' + (index === 0 ? ' active' : '');
                tab.textContent = tabLabel;
                tab.onclick = () => switchTab(index);
                tabsContainer.appendChild(tab);

                // Create content
                const content = document.createElement('div');
                content.className = 'sheet-content' + (index === 0 ? ' active' : '');
                content.id = 'sheet-' + index;
                content.innerHTML = generatePropertyMetaHTML(sheet.propertyMeta) + generateTableHTML(sheet.data, processedData.selectedColumns, sheet.sheetName || baseName);
                contentsContainer.appendChild(content);
            });

            // Add Samlet tab
            const grandIndex = processedData.allData.length;

            const grandTab = document.createElement('button');
            grandTab.className = 'sheet-tab';
            grandTab.textContent = 'Samlet';
            grandTab.onclick = () => switchTab(grandIndex);
            tabsContainer.appendChild(grandTab);

            const grandContent = document.createElement('div');
            grandContent.className = 'sheet-content';
            grandContent.id = 'sheet-' + grandIndex;
            const grandCols = (() => {
                const cols = (processedData.selectedColumns || []).slice();
                const bfeCol = 'Ejendomsnummer (BFE-nr.)';
                if (!cols.includes(bfeCol)) cols.splice(1, 0, bfeCol); // after Bygningsnr.
                return cols;
            })();
            grandContent.innerHTML = generateTableHTML(processedData.grandTotals, grandCols, 'Samlet');
            contentsContainer.appendChild(grandContent);

            modal.classList.add('show');
        }

        function closePreview() {
            const modal = document.getElementById('previewModal');
            modal.classList.remove('show');
        }

        function switchTab(index) {
            // Update tab styles
            document.querySelectorAll('.sheet-tab').forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Update content visibility
            document.querySelectorAll('.sheet-content').forEach((content, i) => {
                if (i === index) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
        }

        
        function openGrandTotal() {
            if (!processedData) {
                // If data not processed yet, open preview after processing
                const btn = document.getElementById('processButton');
                if (btn && !btn.disabled) {
                    btn.click();
                    // showPreview() will run after processing finishes (processFiles calls it)
                    // We can't reliably hook that here without rewriting, so just return.
                }
                return;
            }
            showPreview();
            // Samlet tab is the last one (after all addresses)
            switchTab(processedData.allData.length);
        }


        const ANDEN_DATA_COLS = new Set([
            'Opf√∏relses√•r',
            'Antal etager u. k√¶lder & tagetage',
            'Yderv√¶ggens materiale',
            'Tagd√¶kningsmateriale',
            'Bygningens anvendelse',
            'Erhvervsareal'
        ]);

        const QUALITY_COLS = new Set(['_Warnings','_Confidence']);

        const SUMMABLE_COLS = new Set([
            'Samlet bygningsareal',
            'Samlet k√¶lderareal',
            'Samlet tagetageareal',
            'Heraf udnyttet tagetage',
            'Samlet andet areal',
            'Bebygget areal'
        ]);

        
        function trimAtParen(v) {
            if (!v) return v;
            const idx = v.indexOf('(');
            if (idx > 0) return v.slice(0, idx).trim();
            return v.trim();
        }

function escapeHtml(v){
            if (v === null || v === undefined) return "";
            return String(v)
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#39;");
        }


        function generatePropertyMetaHTML(propertyMeta) {
            if (!propertyMeta) return '';
            const headers = ['Kommunenummer', 'Matrikelnummer', 'Ejendomsnummer (BFE-nr.)'];
            const hasAny = headers.some(h => propertyMeta[h] && String(propertyMeta[h]).trim() !== '');
            if (!hasAny) return '';
            let html = '<div class="meta-table-wrap"><table class="meta-table"><thead><tr>';
            headers.forEach(h => { html += `<th>${escapeHtml(h)}</th>`; });
            html += '</tr></thead><tbody><tr>';
            headers.forEach(h => { html += `<td>${escapeHtml(propertyMeta[h] ?? '-')}</td>`; });
            html += '</tr></tbody></table></div>';
            return html;
        }

function generateTableHTML(data, columns, sheetName) {
            if (!data || data.length === 0) {
                return '<p>Ingen data</p>';
            }

            // Hide "Anden data" columns in Samlet
            let cols = columns.slice();
            if (sheetName === 'Samlet') {
                cols = cols.filter(c => !ANDEN_DATA_COLS.has(c));
            }

            // Order: base cols, Total, then Anden data cols (and quality cols last)
            const andenCols = cols.filter(c => ANDEN_DATA_COLS.has(c));
            const qualityCols = cols.filter(c => QUALITY_COLS.has(c));
            const baseCols = cols.filter(c => !ANDEN_DATA_COLS.has(c) && !QUALITY_COLS.has(c));

            let html = '<table class="preview-table"><thead><tr>';

            baseCols.forEach(col => { html += `<th>${col}</th>`; });
            html += '<th>Total (row sum)</th>';
            andenCols.forEach(col => { html += `<th>${col}</th>`; });
            qualityCols.forEach(col => { html += `<th>${col}</th>`; });

            html += '</tr></thead><tbody>';

            data.forEach((row, index) => {
                const isTotal = index === data.length - 1 || typeof row['Bygningsnr.'] === 'string';
                const rowClass = isTotal ? 'total-row' : '';

                let rowSum = 0;
                baseCols.forEach(col => {
                    if (SUMMABLE_COLS.has(col)) {
                        const val = row[col];
                        if (typeof val === 'number' && !isNaN(val)) rowSum += val;
                    }
                });

                html += `<tr class="${rowClass}">`;

                baseCols.forEach(col => {
                    let val = row[col];
                    if (val === undefined || val === null || val === '') val = '-';
                    html += `<td>${val}</td>`;
                });

                html += `<td class="row-total">${rowSum}</td>`;

                andenCols.forEach(col => {
                    let val = row[col];
                    if (isTotal) val = '-';
                    if (val === undefined || val === null || val === '') val = '-';
                    html += `<td>${val}</td>`;
                });

                qualityCols.forEach(col => {
                    let val = row[col];
                    if (val === undefined || val === null || val === '') val = '-';
                    html += `<td>${val}</td>`;
                });

                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        
        
        
        // Failure box actions
        if (bfeFailCopyBtn) {
            bfeFailCopyBtn.addEventListener('click', async () => {
                if (!fetchFailures.length) return;
                const text = fetchFailures.map(x => x.bfe).join('\n');
                try {
                    await navigator.clipboard.writeText(text);
                    if (bfeBatchHint) bfeBatchHint.textContent = `Kopieret ${fetchFailures.length} fejlede BFE-numre.`;
                } catch (e) {
                    if (bfeBatchHint) bfeBatchHint.textContent = 'Kunne ikke kopiere automatisk. Marker og kopi√©r manuelt fra listen.';
                }
            });
        }
        if (bfeFailClearBtn) {
            bfeFailClearBtn.addEventListener('click', () => {
                clearAllFetchFailures();
                if (bfeBatchHint) bfeBatchHint.textContent = 'Fejllisten er ryddet.';
            });
        }
        if (bfeFailRetryBtn) {
            bfeFailRetryBtn.addEventListener('click', async () => {
                if (!fetchFailures.length) return;
                // Put only failed BFEs into the batch textarea (so user can see them)
                if (bfeBatchInput) bfeBatchInput.value = fetchFailures.map(x => x.bfe).join('\n');
                // Trigger existing batch fetch button (uses proxy)
                if (bfeBatchFetchBtn && !bfeBatchFetchBtn.disabled) {
                    bfeBatchFetchBtn.click();
                }
            });
        }

function downloadExcel() {
            if (!processedData) return;

            const wb = XLSX.utils.book_new();

            // Make Excel-safe, unique sheet names (max 31 chars)
            const used = new Set();
            function makeSheetName(name) {
                let base = (name || 'Unknown').toString().trim() || 'Unknown';
                // Remove characters Excel doesn't like in sheet names: : \ / ? * [ ]
                base = base.replace(/[:\\\/\?\*\[\]]/g, ' ');
                base = base.replace(/\s+/g, ' ').trim();
                if (!base) base = 'Unknown';

                // Reserve space for suffix
                let candidate = base.substring(0, 31);
                let n = 1;
                while (used.has(candidate)) {
                    n += 1;
                    const suffix = ` (${n})`;
                    const maxBase = 31 - suffix.length;
                    candidate = base.substring(0, Math.max(1, maxBase)).trim() + suffix;
                }
                used.add(candidate);
                return candidate;
            }

            // Add individual sheets
            processedData.allData.forEach(sheet => {
                const metaHeaders = ['Kommunenummer', 'Matrikelnummer', 'Ejendomsnummer (BFE-nr.)'];
                const aoa = [];
                // Property meta table (always on top)
                aoa.push(metaHeaders);
                aoa.push(metaHeaders.map(h => (sheet.propertyMeta && sheet.propertyMeta[h] != null) ? sheet.propertyMeta[h] : ''));
                aoa.push([]);

                // Main table (selected columns)
                const cols = (processedData && processedData.selectedColumns && processedData.selectedColumns.length)
                    ? processedData.selectedColumns
                    : (sheet.data && sheet.data[0] ? Object.keys(sheet.data[0]) : []);

                // Ensure "Total (row sum)" column from preview is included in Excel if it exists in the data.
                // In data the key is "Total".
                const hasRowTotal = (Array.isArray(sheet.data) && sheet.data.some(r => r && r['Total'] != null));
                if (hasRowTotal && !cols.includes('Total')) cols.push('Total');

                aoa.push(cols);

                // Ensure the same total row shown in preview is also included in Excel.
                // If the last row is not a computed total row, compute one and append it.
                const rows = Array.isArray(sheet.data) ? [...sheet.data] : [];
                const last = rows.length ? rows[rows.length - 1] : null;
                const looksLikeTotal = last && (rows.length === 0 ? false : (typeof last['Bygningsnr.'] === 'string' && last['Bygningsnr.'] === sheet.sheetName));

                if (!looksLikeTotal && rows.length) {
                    const totalRow = {};
                    totalRow['Bygningsnr.'] = sheet.sheetName;

                    cols.forEach(col => {
                        if (col === 'Bygningsnr.') return;

                        if (typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(col)) {
                            const sum = rows.reduce((acc, b) => {
                                const v = b[col];
                                const val = (typeof v === 'number') ? v : (parseInt(String(v || '').replace(/[^0-9]/g,''), 10) || 0);
                                return acc + val;
                            }, 0);
                            totalRow[col] = sum;
                            return;
                        }

                        if (col === '_Confidence') {
                            const vals = rows
                                .map(b => (typeof b[col] === 'number' ? b[col] : parseInt(b[col], 10)))
                                .filter(v => typeof v === 'number' && !isNaN(v));
                            totalRow[col] = vals.length ? Math.round(vals.reduce((a, x) => a + x, 0) / vals.length) : '-';
                            return;
                        }
                        if (col === '_Warnings') { totalRow[col] = '-'; return; }

                        totalRow[col] = '-';
                    });

                    // Total column (if selected)
                    if (cols.includes('Total')) {
                        const rowTotal = Object.keys(totalRow)
                            .filter(k => k !== 'Bygningsnr.' && k !== 'Total')
                            .reduce((acc, k) => acc + ((typeof SUMMABLE_COLS !== 'undefined' && SUMMABLE_COLS.has(k)) ? (parseInt(totalRow[k], 10) || 0) : 0), 0);
                        totalRow['Total'] = rowTotal;
                    }

                    rows.push(totalRow);
                }

                rows.forEach(r => {
                    aoa.push(cols.map(c => {
                        if (!r) return '';
                        if (c === 'Total') {
                            // "Total (row sum)" is shown in preview even if it's not stored in the row.
                            // Compute it from the summable columns when missing.
                            if (r['Total'] != null && r['Total'] !== '') return r['Total'];
                            let sum = 0;
                            if (typeof SUMMABLE_COLS !== 'undefined') {
                                cols.forEach(cc => {
                                    if (cc === 'Bygningsnr.' || cc === 'Total') return;
                                    if (SUMMABLE_COLS.has(cc)) {
                                        const v = r[cc];
                                        const n = (typeof v === 'number') ? v : (parseInt(String(v || '').replace(/[^0-9]/g,''), 10) || 0);
                                        sum += n;
                                    }
                                });
                            }
                            return sum;
                        }
                        return (r[c] != null) ? r[c] : '';
                    }));
                });

                const ws = XLSX.utils.aoa_to_sheet(aoa);
                const safeName = makeSheetName(sheet.sheetName);
                XLSX.utils.book_append_sheet(wb, ws, safeName);
            });

            // Add grand total sheet (unique name too)
            const grandTotalWs = XLSX.utils.json_to_sheet(processedData.grandTotals || []);
            XLSX.utils.book_append_sheet(wb, grandTotalWs, makeSheetName('Samlet'));

            XLSX.writeFile(wb, 'bbr_data.xlsx');

            showStatus('success', '‚úì Excel fil downloadet!');
            closePreview();
        }

        // Close modal when clicking outside when clicking outside when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('previewModal');
            if (event.target === modal) {
                closePreview();
            }
        }
    
</script>

</body>
</html>